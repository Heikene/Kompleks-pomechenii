from __future__ import annotations

import argparse
import re
import sys
from copy import deepcopy
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal, InvalidOperation, ROUND_HALF_UP, getcontext
from pathlib import Path
from typing import List, Optional

from PySide6.QtCore import Qt, QTimer, QObject, QEvent
from PySide6.QtGui import QKeySequence
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QLineEdit, QPushButton,
    QFileDialog, QMessageBox, QSpinBox, QTableWidget, QTableWidgetItem,
    QGridLayout, QVBoxLayout, QHBoxLayout, QScrollArea, QFrame
)

from docx import Document
from docx.oxml import OxmlElement
from docx.oxml.ns import qn

# ---------- Настройки точности ----------
getcontext().prec = 28

ROUNDING_MODE = ROUND_HALF_UP
SPEED_PLACES = 2
FLOW_PLACES = 2
AREA_PLACES = 2
SEC_PER_HOUR = Decimal(3600)

# ---------- CLI ----------
CLI = argparse.Namespace(
    template="",
    rooms=0,
    nums=[],
    names=[],
    klasses=[],
    areas=[],
    filters=[],
    points=[],
    airflows=[],  # проектные расходы м3/ч по помещениям
    auto_save="",
    auto_close=False,
)

# ---------- Decimal utils ----------
def to_decimal(s: str) -> Decimal:
    s = (str(s).strip()
         .replace("\u00A0", "")
         .replace("\u202F", "")
         .replace(" ", "")
         .replace(",", "."))
    try:
        return Decimal(s)
    except InvalidOperation:
        raise ValueError(f"Некорректное число: «{s}»")

def fmt(n: Decimal, places=2) -> str:
    q = Decimal(10) ** -places
    return str(n.quantize(q, rounding=ROUNDING_MODE)).replace(".", ",")

def fmt_speed(x: Decimal) -> str: return fmt(x, SPEED_PLACES)
def fmt_flow(x: Decimal) -> str: return fmt(x, FLOW_PLACES)
def fmt_area(x: Decimal) -> str: return fmt(x, AREA_PLACES)

def _safe_parse_decimal(s: str) -> Optional[Decimal]:
    s = (s or "").strip()
    if not s:
        return None
    try:
        return to_decimal(s)
    except Exception:
        return None

def _to_int(s: str, default: int = 0) -> int:
    try:
        return int(str(s).strip())
    except Exception:
        return default

# ---------- DOCX helpers ----------
def write_cell_text(cell, text: str):
    p = cell.paragraphs[0] if cell.paragraphs else cell.add_paragraph()
    if p.runs:
        p.runs[0].text = text
        for r in p.runs[1:]:
            r.text = ""
    else:
        p.add_run(text)

def cell_text_all_runs(cell) -> str:
    if cell is None:
        return ""
    return "".join(run.text for p in cell.paragraphs for run in p.runs) \
        .replace("\u00A0", " ").replace("\u202F", " ")

def iter_cells_safe(row):
    try:
        return list(row.cells)
    except Exception:
        return []

def get_cell_safe(row, col_idx):
    try:
        cells = row.cells
        if 0 <= col_idx < len(cells):
            return cells[col_idx]
    except Exception:
        return None
    return None

def write_if_cell(row, col_idx, text: str):
    c = get_cell_safe(row, col_idx)
    if c is not None:
        write_cell_text(c, text)

def _norm_head(s: str) -> str:
    s = s.replace("\u00A0", " ").replace("\u202F", " ").lower()
    s = s.replace("ё", "е")
    return re.sub(r"[^a-zа-я]+", "", s)

def insert_copies_after_tr(last_tr, template_tr, times=1):
    cur = last_tr
    for _ in range(times):
        cp = deepcopy(template_tr)
        cur.addnext(cp)
        cur = cp
    return cur

# --- vMerge ---
def clear_vmerge(cell):
    tcPr = cell._tc.get_or_add_tcPr()
    for child in list(tcPr):
        if child.tag.endswith("}vMerge"):
            tcPr.remove(child)

def set_vmerge(cell, restart=False):
    tcPr = cell._tc.get_or_add_tcPr()
    for child in list(tcPr):
        if child.tag.endswith("}vMerge"):
            tcPr.remove(child)
    vMerge = OxmlElement("w:vMerge")
    vMerge.set(qn("w:val"), "restart" if restart else "continue")
    tcPr.append(vMerge)

def vmerge_cells(cells, top_value):
    if not cells:
        return
    for c in cells:
        clear_vmerge(c)
    write_cell_text(cells[0], top_value)
    set_vmerge(cells[0], restart=True)
    for c in cells[1:]:
        write_cell_text(c, "")
        set_vmerge(c, restart=False)

def collect_column_cells(table, start_row, n_rows, col_idx):
    if col_idx is None:
        return []
    if start_row < 0 or start_row + n_rows > len(table.rows):
        return []
    out = []
    for r in range(start_row, start_row + n_rows):
        row = table.rows[r]
        c = get_cell_safe(row, col_idx)
        if c is None:
            return []
        out.append(c)
    return out

# --- поиск таблицы Test11 ---
def find_table_and_template_row(doc):
    for table in doc.tables:
        for r, row in enumerate(table.rows):
            cells = iter_cells_safe(row)
            if not any("{num}" in cell_text_all_runs(c) for c in cells):
                continue

            col_filter = col_S = col_num = col_speed = None
            fact_cols = []
            for c, cell in enumerate(cells):
                txt = cell_text_all_runs(cell)
                if "{filter_num}" in txt and col_filter is None: col_filter = c
                if "{S}" in txt and col_S is None: col_S = c
                if "{num}" in txt and col_num is None: col_num = c
                if "{avg_speed}" in txt and col_speed is None: col_speed = c
                if "{fact}" in txt: fact_cols.append(c)

            if None not in (col_filter, col_S, col_num, col_speed):
                col_fact_left = fact_cols[0] if len(fact_cols) >= 1 else None
                col_fact_right = fact_cols[1] if len(fact_cols) >= 2 else None
                return table, r, col_filter, col_S, col_num, col_speed, col_fact_left, col_fact_right

    return None, None, None, None, None, None, None, None

def find_header_row(table, below_row_idx):
    for r in range(below_row_idx - 1, -1, -1):
        row_text = " | ".join(cell_text_all_runs(c).lower() for c in iter_cells_safe(table.rows[r]))
        if ("помещен" in row_text) or ("{$#}" in row_text) or ("{room}" in row_text) or ("###" in row_text):
            return r
    return None

def find_yes_no_columns(table, before_row_idx):
    col_yes = col_no = None
    for r in range(before_row_idx - 1, -1, -1):
        for c, cell in enumerate(iter_cells_safe(table.rows[r])):
            t = _norm_head(cell_text_all_runs(cell))
            if col_yes is None and (("да" in t) or ("yes" in t)):
                col_yes = c
            if col_no is None and (("нет" in t) or ("no" in t)):
                col_no = c
        if col_yes is not None and col_no is not None:
            break
    return col_yes, col_no

def find_mean_row_near(table, start_row, span):
    keys = ("средне", "average")
    def norm(s: str) -> str:
        return " ".join(s.replace("\u00A0", " ").replace("\u202F", " ").lower().split())
    end = min(start_row + span + 2, len(table.rows))
    for r in range(start_row, end):
        row_text = norm(" | ".join(cell_text_all_runs(c) for c in iter_cells_safe(table.rows[r])))
        if any(k in row_text for k in keys):
            return r
    return None

def make_room_value(num: str, name: str) -> str:
    num = (num or "").strip()
    name = (name or "").strip()
    if num and name:
        return f"{num}:{name}"
    return num or name

def replace_room_in_row(row, room_value: str, klass: str = ""):
    klass = (klass or "").strip()
    done = False

    for cell in iter_cells_safe(row):
        txt = cell_text_all_runs(cell)
        new_txt = txt

        if "{$#}" in new_txt:
            new_txt = new_txt.replace("{$#}", room_value)
        if "{room}" in new_txt or "{ROOM}" in new_txt:
            new_txt = new_txt.replace("{room}", room_value).replace("{ROOM}", room_value)

        if klass:
            new_txt = new_txt.replace("###", klass).replace("{klass}", klass).replace("{KLASS}", klass)

        if new_txt != txt:
            write_cell_text(cell, new_txt)
            done = True

    if done:
        return

    pattern = re.compile(r"(помещени[ея]\s*[:=—\-]?\s*)(.*)$", flags=re.IGNORECASE)
    for cell in iter_cells_safe(row):
        txt = cell_text_all_runs(cell)
        if "помещен" in txt.lower():
            if pattern.search(txt):
                new_txt = pattern.sub(lambda m: m.group(1) + room_value, txt)
            else:
                new_txt = txt.strip() + " " + room_value
            if klass:
                new_txt = new_txt.replace("###", klass).replace("{klass}", klass).replace("{KLASS}", klass)
            write_cell_text(cell, new_txt)
            return

    c0 = get_cell_safe(row, 0)
    if c0 is not None:
        base = f"Помещение {room_value}"
        if klass:
            base = base.replace("###", klass)
        write_cell_text(c0, base)

# ---------- Excel-like QTableWidget ----------
class SpreadsheetTable(QTableWidget):
    """QTableWidget с Excel-вставкой/копированием."""
    def keyPressEvent(self, e):
        ctrl = bool(e.modifiers() & Qt.ControlModifier)
        if ctrl and e.key() == Qt.Key_C:
            self._copy_selection()
            return
        if ctrl and e.key() == Qt.Key_V:
            if self._paste_clipboard():
                return
        super().keyPressEvent(e)

    def _copy_selection(self):
        rngs = self.selectedRanges()
        if rngs:
            r = rngs[0]
            rows = range(r.topRow(), r.bottomRow() + 1)
            cols = range(r.leftColumn(), r.rightColumn() + 1)
        else:
            rows = range(0, self.rowCount())
            cols = range(0, self.columnCount())

        lines = []
        for i in rows:
            vals = []
            for j in cols:
                it = self.item(i, j)
                vals.append("" if it is None else it.text())
            lines.append("\t".join(vals))
        QApplication.clipboard().setText("\n".join(lines))

    def _paste_clipboard(self) -> bool:
        text = QApplication.clipboard().text()
        if not text:
            return False

        rows_data = [
            [c.strip() for c in row.replace(";", "\t").split("\t")]
            for row in text.splitlines()
            if row.strip() != ""
        ]
        if not rows_data:
            return False

        rngs = self.selectedRanges()
        start_row = rngs[0].topRow() if rngs else 0
        start_col = rngs[0].leftColumn() if rngs else 0

        for i, row_vals in enumerate(rows_data):
            for j, val in enumerate(row_vals):
                r = start_row + i
                c = start_col + j
                if r >= self.rowCount() or c >= self.columnCount():
                    continue
                it = self.item(r, c)
                if it is None:
                    it = QTableWidgetItem()
                    self.setItem(r, c, it)
                it.setText(val)
        return True

# ---------- Пастинг матрицы в QLineEdit скоростей ----------
def _split_paste_matrix(text: str) -> List[str]:
    text = text.strip()
    if not text:
        return []
    lines = re.split(r"\r?\n", text)
    vals: List[str] = []
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if "\t" in line:
            vals.extend([c.strip() for c in line.split("\t") if c.strip() != ""])
        elif ";" in line:
            vals.extend([c.strip() for c in line.split(";") if c.strip() != ""])
        else:
            vals.extend([c.strip() for c in re.split(r"\s+", line) if c.strip() != ""])
    return vals

class SpeedPasteFilter(QObject):
    """
    Ctrl+V в любом speed QLineEdit:
    если в буфере матрица, вставляем последовательно в speed_fields_flat начиная с текущего.
    """
    def __init__(self, get_flat_list, schedule_live_update):
        super().__init__()
        self._get_flat_list = get_flat_list
        self._schedule_live_update = schedule_live_update

    def eventFilter(self, obj, event):
        if event.type() == QEvent.KeyPress:
            if event.matches(QKeySequence.Paste):
                data = QApplication.clipboard().text()
                if any(sym in data for sym in ("\n", "\r", "\t", ";")):
                    vals = _split_paste_matrix(data)
                    if not vals:
                        return True
                    flat = self._get_flat_list()
                    if not hasattr(obj, "_flat_idx"):
                        return False
                    start = int(getattr(obj, "_flat_idx"))
                    for w, v in zip(flat[start:], vals):
                        w.setText(v)
                    self._schedule_live_update()
                    return True
        return False

# ---------- Data ----------
@dataclass
class RoomRow:
    num: str
    name: str
    s_m2: str
    filters: str
    points: str

# ---------- Main Window ----------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Калькулятор расхода воздуха (мультипомещения)")

        self._live_job: Optional[QTimer] = None

        self.rooms_table = SpreadsheetTable()
        self.rooms_table.setColumnCount(5)
        self.rooms_table.setHorizontalHeaderLabels(["Помещение", "Название", "S, м²", "Фильтров", "Точек"])
        self.rooms_table.verticalHeader().setVisible(True)

        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.speeds_root = QWidget()
        self.speeds_layout = QVBoxLayout(self.speeds_root)
        self.speeds_layout.setContentsMargins(6, 6, 6, 6)
        self.speeds_layout.setSpacing(10)
        self.scroll.setWidget(self.speeds_root)

        self.speed_fields: List[List[List[QLineEdit]]] = []  # [room][filter][point]
        self.speed_fields_flat: List[QLineEdit] = []

        self.room_crit_labels: List[QLabel] = []
        self.room_total_labels: List[QLabel] = []
        self.room_pass_labels: List[QLabel] = []
        self.filter_s_labels: List[List[QLabel]] = []
        self.filter_avg_labels: List[List[QLabel]] = []
        self.filter_flow_labels: List[List[QLabel]] = []

        self._build_ui()

        self._speed_paste_filter = SpeedPasteFilter(
            get_flat_list=lambda: self.speed_fields_flat,
            schedule_live_update=self._schedule_live_update
        )

        if CLI.template:
            self.template_path.setText(CLI.template)
        if CLI.rooms and CLI.rooms > 0:
            self.rooms_count.setValue(CLI.rooms)
        else:
            self.rooms_count.setValue(max(1, int(CLI.rooms or 1)))

        self.create_rooms()

    # ---------- UI ----------
    def _build_ui(self):
        cw = QWidget()
        main = QVBoxLayout(cw)

        r1 = QHBoxLayout()
        r1.addWidget(QLabel("Шаблон DOCX (опц.):"))
        self.template_path = QLineEdit()
        r1.addWidget(self.template_path, 1)
        btn_browse = QPushButton("Обзор…")
        btn_browse.clicked.connect(self.choose_template)
        r1.addWidget(btn_browse)
        main.addLayout(r1)

        r2 = QHBoxLayout()
        r2.addWidget(QLabel("Кол-во помещений:"))
        self.rooms_count = QSpinBox()
        self.rooms_count.setRange(1, 300)
        r2.addWidget(self.rooms_count)

        btn_rooms = QPushButton("Создать помещения")
        btn_rooms.clicked.connect(self.create_rooms)
        r2.addWidget(btn_rooms)

        btn_speeds = QPushButton("Создать поля для скоростей")
        btn_speeds.clicked.connect(self.create_speed_fields)
        r2.addWidget(btn_speeds)

        btn_calc = QPushButton("Рассчитать")
        btn_calc.clicked.connect(self.calculate_only)
        r2.addWidget(btn_calc)

        btn_save = QPushButton("Сохранить DOCX")
        btn_save.clicked.connect(self.save_docx)
        r2.addWidget(btn_save)

        r2.addStretch(1)
        main.addLayout(r2)

        main.addWidget(self.rooms_table, 0)

        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        main.addWidget(line)

        main.addWidget(self.scroll, 1)

        r4 = QHBoxLayout()
        r4.addWidget(QLabel("Средняя скорость (справочно):"))
        self.avg_ref = QLineEdit()
        self.avg_ref.setReadOnly(True)
        self.avg_ref.setFixedWidth(120)
        r4.addWidget(self.avg_ref)
        r4.addStretch(1)
        main.addLayout(r4)

        self.setCentralWidget(cw)
        self.resize(1000, 750)

        self.rooms_table.itemChanged.connect(lambda *_: self._schedule_live_update())

    def choose_template(self):
        p, _ = QFileDialog.getOpenFileName(self, "Выберите шаблон Word", "", "Word Document (*.docx)")
        if p:
            self.template_path.setText(p)

    # ---------- rooms ----------
    def create_rooms(self):
        n = int(self.rooms_count.value())
        self.rooms_table.blockSignals(True)
        self.rooms_table.setRowCount(n)

        for r in range(n):
            num = (CLI.nums[r] if r < len(CLI.nums) and CLI.nums[r] else str(r + 1))
            name = (CLI.names[r] if r < len(CLI.names) else "")
            s = (CLI.areas[r] if r < len(CLI.areas) else "1")
            f = (CLI.filters[r] if r < len(CLI.filters) else "1")
            p = (CLI.points[r] if r < len(CLI.points) else "2")

            for c, val in enumerate([num, name, s, f, p]):
                it = self.rooms_table.item(r, c)
                if it is None:
                    it = QTableWidgetItem()
                    self.rooms_table.setItem(r, c, it)
                it.setText(str(val))

        self.rooms_table.blockSignals(False)
        self._schedule_live_update()

    def _get_rooms(self) -> List[RoomRow]:
        out: List[RoomRow] = []
        for r in range(self.rooms_table.rowCount()):
            def cell(c: int) -> str:
                it = self.rooms_table.item(r, c)
                return (it.text().strip() if it else "")
            out.append(RoomRow(
                num=cell(0),
                name=cell(1),
                s_m2=cell(2),
                filters=cell(3),
                points=cell(4),
            ))
        return out

    # ---------- speeds ----------
    def _clear_speeds_ui(self):
        while self.speeds_layout.count():
            item = self.speeds_layout.takeAt(0)
            w = item.widget()
            if w is not None:
                w.deleteLater()

        self.speed_fields = []
        self.speed_fields_flat = []

        self.room_crit_labels = []
        self.room_total_labels = []
        self.room_pass_labels = []
        self.filter_s_labels = []
        self.filter_avg_labels = []
        self.filter_flow_labels = []

    def create_speed_fields(self):
        rooms = self._get_rooms()
        if not rooms:
            QMessageBox.warning(self, "Ошибка", "Сначала создайте помещения.")
            return

        for i, rr in enumerate(rooms, start=1):
            if not rr.name.strip():
                QMessageBox.warning(self, "Ошибка", f"Не заполнено название (строка {i}).")
                return
            S = _safe_parse_decimal(rr.s_m2)
            if S is None or S <= 0:
                QMessageBox.warning(self, "Ошибка", f"Площадь S должна быть > 0 (строка {i}).")
                return
            nf = _to_int(rr.filters, 0)
            np = _to_int(rr.points, 0)
            if nf <= 0 or np <= 0:
                QMessageBox.warning(self, "Ошибка", f"Фильтров и Точек должны быть > 0 (строка {i}).")
                return

        self._clear_speeds_ui()

        for r_idx, rr in enumerate(rooms):
            nf = _to_int(rr.filters, 1)
            np = _to_int(rr.points, 2)

            room_box = QFrame()
            room_box.setFrameShape(QFrame.StyledPanel)
            vb = QVBoxLayout(room_box)
            vb.setContentsMargins(8, 8, 8, 8)
            vb.setSpacing(6)

            title = QLabel(f"Помещение {rr.num}")
            title.setStyleSheet("font-weight: 700;")
            vb.addWidget(title)

            summ = QHBoxLayout()
            summ.addWidget(QLabel("Критерий (м³/ч):"))
            lbl_crit = QLabel("—")
            lbl_crit.setFixedWidth(120)
            summ.addWidget(lbl_crit)

            summ.addSpacing(16)
            summ.addWidget(QLabel("Итого факт. (м³/ч):"))
            lbl_total = QLabel("—")
            lbl_total.setFixedWidth(120)
            summ.addWidget(lbl_total)

            summ.addSpacing(16)
            summ.addWidget(QLabel("Результат:"))
            lbl_pass = QLabel("—")
            lbl_pass.setStyleSheet("font-weight: 700;")
            lbl_pass.setFixedWidth(60)
            summ.addWidget(lbl_pass)

            summ.addStretch(1)
            vb.addLayout(summ)

            self.room_crit_labels.append(lbl_crit)
            self.room_total_labels.append(lbl_total)
            self.room_pass_labels.append(lbl_pass)

            room_speed_filters: List[List[QLineEdit]] = []
            room_s_lbls: List[QLabel] = []
            room_avg_lbls: List[QLabel] = []
            room_flow_lbls: List[QLabel] = []

            for f_idx in range(nf):
                fl_title = QLabel(f"  Фильтр {f_idx+1}")
                fl_title.setStyleSheet("font-style: italic;")
                vb.addWidget(fl_title)

                grid = QGridLayout()
                grid.setHorizontalSpacing(10)
                grid.setVerticalSpacing(4)

                filt_points: List[QLineEdit] = []
                for p_idx in range(np):
                    lab = QLabel(f"    № точки {p_idx+1} (м/с):")
                    e = QLineEdit()
                    e.setFixedWidth(120)
                    e._flat_idx = len(self.speed_fields_flat)  # type: ignore[attr-defined]
                    e.installEventFilter(self._speed_paste_filter)
                    e.textChanged.connect(lambda *_: self._schedule_live_update())
                    grid.addWidget(lab, p_idx, 0, Qt.AlignRight)
                    grid.addWidget(e, p_idx, 1, Qt.AlignLeft)

                    filt_points.append(e)
                    self.speed_fields_flat.append(e)

                vb.addLayout(grid)

                row_sum = QHBoxLayout()
                row_sum.addWidget(QLabel("    S, м²:"))
                lbl_s = QLabel("—")
                lbl_s.setFixedWidth(100)
                row_sum.addWidget(lbl_s)

                row_sum.addSpacing(16)
                row_sum.addWidget(QLabel("Средняя (м/с):"))
                lbl_avg = QLabel("—")
                lbl_avg.setFixedWidth(100)
                row_sum.addWidget(lbl_avg)

                row_sum.addSpacing(16)
                row_sum.addWidget(QLabel("Итого факт (м³/ч):"))
                lbl_flow = QLabel("—")
                lbl_flow.setFixedWidth(120)
                row_sum.addWidget(lbl_flow)

                row_sum.addStretch(1)
                vb.addLayout(row_sum)

                room_s_lbls.append(lbl_s)
                room_avg_lbls.append(lbl_avg)
                room_flow_lbls.append(lbl_flow)

                room_speed_filters.append(filt_points)

            self.speed_fields.append(room_speed_filters)
            self.filter_s_labels.append(room_s_lbls)
            self.filter_avg_labels.append(room_avg_lbls)
            self.filter_flow_labels.append(room_flow_lbls)

            self.speeds_layout.addWidget(room_box)

        self.speeds_layout.addStretch(1)
        self._schedule_live_update()

    # ---------- live update ----------
    def _schedule_live_update(self):
        if self._live_job is None:
            self._live_job = QTimer(self)
            self._live_job.setSingleShot(True)
            self._live_job.timeout.connect(self._live_update)
        self._live_job.start(120)

    def _live_update(self):
        rooms = self._get_rooms()
        n = len(rooms)

        crit: List[Optional[Decimal]] = []
        for r in range(n):
            txt = (CLI.airflows[r] if r < len(CLI.airflows) else "") or ""
            crit.append(_safe_parse_decimal(txt))

        for r_idx, rr in enumerate(rooms):
            S = _safe_parse_decimal(rr.s_m2)
            if S is not None and S <= 0:
                S = None

            if r_idx < len(self.room_crit_labels):
                self.room_crit_labels[r_idx].setText(fmt_flow(crit[r_idx]) if crit[r_idx] is not None else "—")

            if r_idx >= len(self.speed_fields):
                if r_idx < len(self.room_total_labels):
                    self.room_total_labels[r_idx].setText("—")
                if r_idx < len(self.room_pass_labels):
                    self.room_pass_labels[r_idx].setText("—")
                continue

            total_room = Decimal(0)
            have_all = True

            nf = len(self.speed_fields[r_idx])
            for f_idx in range(nf):
                if r_idx < len(self.filter_s_labels) and f_idx < len(self.filter_s_labels[r_idx]):
                    self.filter_s_labels[r_idx][f_idx].setText(fmt_area(S) if S is not None else "—")

                pts = self.speed_fields[r_idx][f_idx]
                vals: List[Decimal] = []
                ok = True
                for e in pts:
                    v = _safe_parse_decimal(e.text())
                    if v is None or v < 0:
                        ok = False
                        break
                    vals.append(v)

                if (not ok) or (S is None) or (len(vals) != len(pts)):
                    if r_idx < len(self.filter_avg_labels) and f_idx < len(self.filter_avg_labels[r_idx]):
                        self.filter_avg_labels[r_idx][f_idx].setText("—")
                    if r_idx < len(self.filter_flow_labels) and f_idx < len(self.filter_flow_labels[r_idx]):
                        self.filter_flow_labels[r_idx][f_idx].setText("—")
                    have_all = False
                    continue

                avg = sum(vals, Decimal(0)) / Decimal(len(vals))
                flow = S * avg * SEC_PER_HOUR

                if r_idx < len(self.filter_avg_labels) and f_idx < len(self.filter_avg_labels[r_idx]):
                    self.filter_avg_labels[r_idx][f_idx].setText(fmt_speed(avg))
                if r_idx < len(self.filter_flow_labels) and f_idx < len(self.filter_flow_labels[r_idx]):
                    self.filter_flow_labels[r_idx][f_idx].setText(fmt_flow(flow))

                total_room += flow

            if r_idx < len(self.room_total_labels):
                self.room_total_labels[r_idx].setText(fmt_flow(total_room) if have_all and nf > 0 else "—")
            if r_idx < len(self.room_pass_labels):
                if have_all and nf > 0 and (crit[r_idx] is not None):
                    self.room_pass_labels[r_idx].setText("ДА" if total_room >= crit[r_idx] else "НЕТ")
                else:
                    self.room_pass_labels[r_idx].setText("—")

        try:
            if self.speed_fields and self.speed_fields[0]:
                vals = []
                for e in self.speed_fields[0][0]:
                    v = _safe_parse_decimal(e.text())
                    if v is None:
                        vals = []
                        break
                    vals.append(v)
                if vals:
                    avg0 = sum(vals, Decimal(0)) / Decimal(len(vals))
                    self.avg_ref.setText(fmt_speed(avg0))
                else:
                    self.avg_ref.setText("—")
        except Exception:
            self.avg_ref.setText("—")

    # ---------- calc / save ----------
    def _collect_inputs_strict(self):
        rooms = self._get_rooms()
        if not rooms:
            raise ValueError("Нет помещений.")

        n_rooms = len(rooms)
        room_names: List[str] = []
        room_nums: List[str] = []
        room_S: List[Decimal] = []
        room_filters: List[int] = []
        room_points: List[int] = []

        for r, rr in enumerate(rooms):
            if not rr.name.strip():
                raise ValueError(f"Не заполнено название для помещения {r+1}.")
            room_names.append(rr.name.strip())

            room_nums.append(rr.num.strip() or str(r + 1))

            S = to_decimal(rr.s_m2)
            if S <= 0:
                raise ValueError(f"Площадь S должна быть > 0 (помещение {r+1}).")
            room_S.append(S)

            nf = _to_int(rr.filters, 0)
            np = _to_int(rr.points, 0)
            if nf <= 0:
                raise ValueError(f"Фильтров на помещение должно быть > 0 (помещение {r+1}).")
            if np <= 0:
                raise ValueError(f"Количество точек должно быть > 0 (помещение {r+1}).")
            room_filters.append(nf)
            room_points.append(np)

        if not self.speed_fields or len(self.speed_fields) != n_rooms:
            raise ValueError("Нажмите «Создать поля для скоростей» и заполните скорости.")

        speeds: List[List[List[Decimal]]] = []
        avgs: List[List[Decimal]] = []

        for r in range(n_rooms):
            if len(self.speed_fields[r]) != room_filters[r]:
                raise ValueError(f"Несовпадение кол-ва фильтров в скоростях (помещение {r+1}).")

            sp_room: List[List[Decimal]] = []
            avg_room: List[Decimal] = []

            for f in range(room_filters[r]):
                pts = self.speed_fields[r][f]
                if len(pts) != room_points[r]:
                    raise ValueError(f"Несовпадение кол-ва точек (помещение {r+1}, фильтр {f+1}).")

                row_vals: List[Decimal] = []
                for i in range(room_points[r]):
                    raw = pts[i].text().strip()
                    if raw == "":
                        raise ValueError(f"Пустая скорость: пом. {r+1}, фильтр {f+1}, точка {i+1}.")
                    v = to_decimal(raw)
                    if v < 0:
                        raise ValueError(f"Отрицательная скорость: пом. {r+1}, фильтр {f+1}, точка {i+1}.")
                    row_vals.append(v)

                sp_room.append(row_vals)
                avg_room.append(sum(row_vals, Decimal(0)) / Decimal(room_points[r]))

            speeds.append(sp_room)
            avgs.append(avg_room)

        room_sum_flow: List[Decimal] = []
        for r in range(n_rooms):
            total = sum((room_S[r] * avgs[r][f] * SEC_PER_HOUR for f in range(room_filters[r])), Decimal(0))
            room_sum_flow.append(total)

        criterion_texts: List[Optional[str]] = []
        for r in range(n_rooms):
            txt = ((CLI.airflows[r] if r < len(CLI.airflows) else "") or "").strip()
            if txt:
                try:
                    criterion_texts.append(fmt_flow(to_decimal(txt)))
                except Exception:
                    criterion_texts.append(txt)
            else:
                criterion_texts.append(None)

        return (n_rooms, room_nums, room_names, room_S, room_filters, room_points,
                speeds, avgs, room_sum_flow, criterion_texts)

    def calculate_only(self):
        try:
            self._live_update()
            (n_rooms, *_rest) = self._collect_inputs_strict()
            QMessageBox.information(self, "Ок", f"Данные корректны. Помещений: {n_rooms}.")
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", str(e))

    def save_docx(self):
        try:
            (n_rooms, room_nums, room_names, room_S, room_filters, room_points,
             speeds, avgs, room_sum_flow, criterion_texts) = self._collect_inputs_strict()

            # ВАЖНО: room_klasses вычисляем ТОЛЬКО тут (когда уже есть n_rooms)
            room_klasses = list(getattr(CLI, "klasses", []) or [])
            if len(room_klasses) < n_rooms:
                room_klasses += [""] * (n_rooms - len(room_klasses))

            template_path = self.template_path.text().strip()
            if not template_path:
                p, _ = QFileDialog.getOpenFileName(self, "Выберите DOCX шаблон Test 11", "", "Word Document (*.docx)")
                if not p:
                    return
                template_path = p
                self.template_path.setText(p)

            try:
                doc = Document(template_path)
            except Exception as e:
                raise ValueError(f"Не удалось открыть шаблон: {e}")

            (table, tpl_row, col_filter, col_S, col_num, col_speed,
             col_fact_left, col_fact_right) = find_table_and_template_row(doc)
            if table is None:
                raise ValueError("В шаблоне не найдена строка со спецификатором {num}. Проверьте таблицу Test 11.")

            missing = []
            if col_filter is None: missing.append("{filter_num}")
            if col_S is None: missing.append("{S}")
            if col_num is None: missing.append("{num}")
            if col_speed is None: missing.append("{avg_speed}")
            if col_fact_left is None: missing.append("{fact}")
            if missing:
                raise ValueError("В строке-шаблоне отсутствуют столбцы: " + ", ".join(missing))

            header_row_idx = find_header_row(table, tpl_row)
            if header_row_idx is None:
                raise ValueError("Не найден заголовок секции «Помещение …» выше строки-шаблона.")

            col_yes, col_no = find_yes_no_columns(table, tpl_row)

            first_yes_no = None
            for c in (col_yes, col_no):
                if c is not None:
                    first_yes_no = c if first_yes_no is None else min(first_yes_no, c)

            col_criterion = None
            if first_yes_no is not None and first_yes_no > 0:
                col_criterion = first_yes_no - 1  # слева от ДА/НЕТ

            data_tr_template = deepcopy(table.rows[tpl_row]._tr)

            mean_row_idx = find_mean_row_near(table, tpl_row, room_points[0])
            has_mean = (mean_row_idx is not None)
            mean_tr_template = deepcopy(table.rows[mean_row_idx]._tr) if has_mean else None

            def merge_block(start_row, n_rows, filter_label, S_value: Decimal):
                filter_cells = collect_column_cells(table, start_row, n_rows, col_filter)
                s_cells = collect_column_cells(table, start_row, n_rows, col_S)
                factL_cells = collect_column_cells(table, start_row, n_rows, col_fact_left)
                vmerge_cells(filter_cells, str(filter_label))
                vmerge_cells(s_cells, fmt_area(S_value))
                if factL_cells:
                    vmerge_cells(factL_cells, cell_text_all_runs(factL_cells[0]))

            # --- room 0 ---
            replace_room_in_row(
                table.rows[header_row_idx],
                make_room_value(room_nums[0], room_names[0]),
                room_klasses[0],
            )

            if room_points[0] > 1:
                last_tr = table.rows[tpl_row]._tr
                last_tr = insert_copies_after_tr(last_tr, data_tr_template, times=room_points[0] - 1)

            block_fact_value = fmt_flow(room_S[0] * avgs[0][0] * SEC_PER_HOUR)
            for i in range(room_points[0]):
                row = table.rows[tpl_row + i]
                write_if_cell(row, col_num, str(i + 1))
                write_if_cell(row, col_speed, fmt_speed(speeds[0][0][i]))
                write_if_cell(row, col_fact_left, block_fact_value if i == 0 else "")
                if col_fact_right is not None:
                    write_if_cell(row, col_fact_right, "")

            if has_mean:
                if tpl_row + room_points[0] >= len(table.rows):
                    last_tr = table.rows[len(table.rows) - 1]._tr
                    last_tr = insert_copies_after_tr(last_tr, mean_tr_template, times=1)
                write_if_cell(table.rows[tpl_row + room_points[0]], col_speed, fmt_speed(avgs[0][0]))

            block_height_for_room0 = room_points[0] + (1 if has_mean else 0)
            merge_block(tpl_row, block_height_for_room0, 1, room_S[0])

            room_block_starts: List[List[int]] = [[tpl_row]]
            current_end_row = tpl_row + block_height_for_room0 - 1

            for f in range(2, room_filters[0] + 1):
                last_tr = table.rows[current_end_row]._tr
                for _ in range(room_points[0]):
                    last_tr = insert_copies_after_tr(last_tr, data_tr_template, times=1)
                if has_mean:
                    last_tr = insert_copies_after_tr(last_tr, mean_tr_template, times=1)

                block_start = current_end_row + 1
                current_end_row = block_start + room_points[0] + (1 if has_mean else 0) - 1

                block_fact_value = fmt_flow(room_S[0] * avgs[0][f - 1] * SEC_PER_HOUR)
                for i in range(room_points[0]):
                    row = table.rows[block_start + i]
                    write_if_cell(row, col_num, str(i + 1))
                    write_if_cell(row, col_speed, fmt_speed(speeds[0][f - 1][i]))
                    write_if_cell(row, col_fact_left, block_fact_value if i == 0 else "")
                    if col_fact_right is not None:
                        write_if_cell(row, col_fact_right, "")
                if has_mean:
                    write_if_cell(table.rows[block_start + room_points[0]], col_speed, fmt_speed(avgs[0][f - 1]))

                merge_block(block_start, room_points[0] + (1 if has_mean else 0), f, room_S[0])
                room_block_starts[0].append(block_start)

            header_tr_template = deepcopy(table.rows[header_row_idx]._tr)

            for r in range(1, n_rooms):
                last_tr = table.rows[current_end_row]._tr
                last_tr = insert_copies_after_tr(last_tr, header_tr_template, times=1)
                room_header_row = current_end_row + 1
                current_end_row = room_header_row

                replace_room_in_row(
                    table.rows[room_header_row],
                    make_room_value(room_nums[r], room_names[r]),
                    room_klasses[r],
                )

                starts_this_room: List[int] = []
                for f in range(1, room_filters[r] + 1):
                    for _ in range(room_points[r]):
                        last_tr = insert_copies_after_tr(last_tr, data_tr_template, times=1)
                    if has_mean:
                        last_tr = insert_copies_after_tr(last_tr, mean_tr_template, times=1)

                    block_start = current_end_row + 1
                    current_end_row = block_start + room_points[r] + (1 if has_mean else 0) - 1

                    block_fact_value = fmt_flow(room_S[r] * avgs[r][f - 1] * SEC_PER_HOUR)
                    for i in range(room_points[r]):
                        row = table.rows[block_start + i]
                        write_if_cell(row, col_num, str(i + 1))
                        write_if_cell(row, col_speed, fmt_speed(speeds[r][f - 1][i]))
                        write_if_cell(row, col_fact_left, block_fact_value if i == 0 else "")
                        if col_fact_right is not None:
                            write_if_cell(row, col_fact_right, "")
                    if has_mean:
                        write_if_cell(table.rows[block_start + room_points[r]], col_speed, fmt_speed(avgs[r][f - 1]))

                    merge_block(block_start, room_points[r] + (1 if has_mean else 0), f, room_S[r])
                    starts_this_room.append(block_start)

                room_block_starts.append(starts_this_room)

            def block_height_fn(room_idx: int) -> int:
                return room_points[room_idx] + (1 if has_mean else 0)

            for r, starts in enumerate(room_block_starts):
                if not starts:
                    continue
                first_start = starts[0]
                last_start = starts[-1]
                seg_start = first_start
                seg_rows = (last_start + block_height_fn(r)) - seg_start

                if col_fact_right is not None:
                    cellsR = collect_column_cells(table, seg_start, seg_rows, col_fact_right)
                    if cellsR:
                        vmerge_cells(cellsR, fmt_flow(room_sum_flow[r]))

                if col_criterion is not None and col_criterion not in (col_yes, col_no):
                    cellsC = collect_column_cells(table, seg_start, seg_rows, col_criterion)
                    if cellsC:
                        top_val = criterion_texts[r] if (r < len(criterion_texts) and criterion_texts[r]) else cell_text_all_runs(cellsC[0])
                        vmerge_cells(cellsC, top_val)

            out_path = (CLI.auto_save or "").strip()
            if not out_path:
                ts = datetime.now().strftime("%Y%m%d_%H%M%S")
                default_name = f"Расчет_воздуха_{ts}.docx"
                p, _ = QFileDialog.getSaveFileName(self, "Сохранить отчёт", default_name, "Word Document (*.docx)")
                if not p:
                    return
                out_path = p

            try:
                Path(out_path).parent.mkdir(parents=True, exist_ok=True)
                doc.save(out_path)
            except PermissionError:
                QMessageBox.critical(self, "Файл занят", "Документ открыт в Word. Закройте и повторите.")
                return

            if not CLI.auto_save:
                QMessageBox.information(self, "Готово", f"Файл сохранён:\n{out_path}")

            if CLI.auto_close:
                self.close()

        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"{e}")

# ---------- CLI parse ----------
def _parse_args(argv):
    p = argparse.ArgumentParser(description="Калькулятор Test 11 (расход приточного воздуха)")
    p.add_argument("--template", default="", help="Путь к DOCX с таблицей Test 11")
    p.add_argument("--rooms", type=int, default=0, help="Количество помещений (предзаполнение)")
    p.add_argument("--nums", default="", help="Номера помещений через ;")
    p.add_argument("--names", default="", help="Названия помещений через ;")
    p.add_argument("--klasses", default="", help="Класс чистоты через ;")
    p.add_argument("--areas", default="", help="Площади через ; (точка или запятая)")
    p.add_argument("--filters", default="", help="Кол-во фильтров на помещение через ;")
    p.add_argument("--points", default="", help="Кол-во точек на помещение через ;")
    p.add_argument("--airflows", default="", help="Проектные расходы, м3/ч, через ; (по помещениям)")
    p.add_argument("--auto-save", default="", help="Путь авто-сохранения (без диалога)")
    p.add_argument("--auto-close", action="store_true", help="Закрыть окно после сохранения")
    args = p.parse_args(argv)

    CLI.template = args.template
    CLI.rooms = max(0, int(args.rooms or 0))
    CLI.auto_save = args.auto_save
    CLI.auto_close = bool(args.auto_close)

    def split_list(s):
        return [x.strip() for x in s.split(";")] if s else []

    CLI.nums = split_list(args.nums)
    CLI.names = split_list(args.names)
    CLI.klasses = split_list(args.klasses)
    CLI.areas = split_list(args.areas)
    CLI.filters = split_list(args.filters)
    CLI.points = split_list(args.points)
    CLI.airflows = split_list(args.airflows)

def main():
    app = QApplication(sys.argv)
    wnd = MainWindow()
    wnd.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    _parse_args(sys.argv[1:])
    main()


# ui/main_window.py
from __future__ import annotations

import sys
import os
import re
import tempfile
import uuid
from copy import deepcopy
from collections import OrderedDict
from datetime import datetime, date
from decimal import Decimal, InvalidOperation
from pathlib import Path
from typing import List, Dict, Any, Tuple, Optional
from ui import word_table2_otch_splitter

from PySide6.QtCore import Qt, QThread, Signal
from PySide6.QtGui import QDragEnterEvent, QDropEvent, QGuiApplication, QKeySequence, QShortcut
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QLineEdit, QListWidget,
    QListWidgetItem, QPushButton, QMessageBox, QFileDialog,
    QGridLayout, QDateEdit, QDialog, QVBoxLayout, QHBoxLayout,
    QSpinBox, QTableWidget, QTableWidgetItem, QProgressBar, QComboBox,
    QTabWidget, QAbstractItemView
)

from docx import Document
from docx.document import Document as DocxDocument
from docx.table import Table
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docxtpl import DocxTemplate, RichText, InlineImage
from docx.shared import Mm, Pt
from docx.image.exceptions import UnrecognizedImageError
from docx.image.image import Image

from pymorphy3 import MorphAnalyzer

import word_test11_splitter

from file_utils import temp_docx
import io_manager
import template_renderer
import table_processor
from logger import logger

from risk_table5 import get_risk_rows, insert_table5_into_doc
import word_table5_splitter
import word_update_all




# =============================================================================
# 1) Защита от падения tpl.render() из-за битых/неподдерживаемых картинок
# =============================================================================
# docxtpl вставляет картинки лениво: ошибка может прилететь при tpl.render(),
# когда InlineImage превращается в строку. Этот патч гарантирует "не упасть".
from docxtpl.inline_image import InlineImage as _TplInlineImage  # noqa

_old_inlineimage_str = _TplInlineImage.__str__


def _safe_inlineimage_str(self):
    try:
        return _old_inlineimage_str(self)
    except UnrecognizedImageError:
        desc = getattr(self, "image_descriptor", None)
        logger.warning(f"Пропущена битая/неподдерживаемая картинка (UnrecognizedImageError): {desc}")
        return ""
    except Exception as e:
        desc = getattr(self, "image_descriptor", None)
        logger.warning(f"Пропущена картинка (ошибка вставки: {e}): {desc}")
        return ""


_TplInlineImage.__str__ = _safe_inlineimage_str


# =============================================================================
# 2) Безопасное создание InlineImage + фильтрация расширений
# =============================================================================
_IMG_EXT = {".png", ".jpg", ".jpeg", ".bmp", ".tif", ".tiff", ".gif"}  # только картинки (НЕ pdf)


def safe_inline_image(tpl: DocxTemplate, path: str, *, width_mm: int = 160, label: str = ""):
    """
    1) Отсекаем несуществующие / не файлы
    2) Отсекаем расширения (только картинки)
    3) Проверяем, что это реально картинка: Image.from_file()
    4) Создаём InlineImage
    """
    if not path:
        return None

    pp = Path(path)
    if not pp.exists() or not pp.is_file():
        logger.warning(f"Пропущен файл для {label} (не найден): {path}")
        return None

    ext = pp.suffix.lower()
    if ext not in _IMG_EXT:
        logger.warning(f"Пропущен файл для {label} (не картинка / pdf не поддерживается): {path}")
        return None

    # ранняя проверка (иначе может упасть позже на render)
    try:
        Image.from_file(str(pp))
    except UnrecognizedImageError:
        logger.warning(f"Пропущен файл для {label} (битая/неподдерживаемая картинка): {path}")
        return None
    except Exception as e:
        logger.warning(f"Пропущен файл для {label} (ошибка проверки картинки: {e}): {path}")
        return None

    try:
        return InlineImage(tpl, str(pp), width=Mm(width_mm))
    except Exception as e:
        logger.warning(f"Пропущен файл для {label} (ошибка создания InlineImage: {e}): {path}")
        return None


def make_inline_images(tpl: DocxTemplate, paths: list[str], *, label: str, width_mm: int = 160) -> list[InlineImage]:
    out: list[InlineImage] = []
    for p in (paths or []):
        ii = safe_inline_image(tpl, p, width_mm=width_mm, label=label)
        if ii is not None:
            out.append(ii)
    return out


# =============================================================================

# =============================================================================
# 4) Spreadsheet-like table
# =============================================================================
class SpreadsheetTable(QTableWidget):
    """QTableWidget с excel-копипастой."""
    def keyPressEvent(self, e):
        ctrl = bool(e.modifiers() & Qt.ControlModifier)
        if ctrl and e.key() == Qt.Key_C:
            self._copy_selection_to_clipboard()
            return
        if ctrl and e.key() == Qt.Key_V:
            self._paste_from_clipboard()
            return
        super().keyPressEvent(e)

    def _copy_selection_to_clipboard(self):
        rngs = self.selectedRanges()
        if rngs:
            r = rngs[0]
            rows = range(r.topRow(), r.bottomRow() + 1)
            cols = range(r.leftColumn(), r.rightColumn() + 1)
        else:
            rows = range(0, self.rowCount())
            cols = range(0, self.columnCount())

        lines = []
        for i in rows:
            vals = []
            for j in cols:
                it = self.item(i, j)
                vals.append("" if it is None else it.text())
            lines.append("\t".join(vals))
        QApplication.clipboard().setText("\n".join(lines))

    def _paste_from_clipboard(self):
        text = QApplication.clipboard().text()
        if not text:
            return

        rows_data = [
            [c.strip() for c in row.replace(";", "\t").split("\t")]
            for row in text.splitlines()
            if row.strip() != ""
        ]
        if not rows_data:
            return

        rngs = self.selectedRanges()
        start_row = rngs[0].topRow() if rngs else max(0, self.currentRow())
        start_col = rngs[0].leftColumn() if rngs else max(0, self.currentColumn())

        need_r = start_row + len(rows_data)
        need_c = start_col + max(len(r) for r in rows_data)

        if self.rowCount() < need_r:
            self.setRowCount(need_r)
        if self.columnCount() < need_c:
            self.setColumnCount(need_c)

        for i, row_vals in enumerate(rows_data):
            for j, val in enumerate(row_vals):
                r = start_row + i
                c = start_col + j
                it = self.item(r, c)
                if it is None:
                    it = QTableWidgetItem()
                    self.setItem(r, c, it)
                it.setText(val)


# =============================================================================
# 5) Dialogs
# =============================================================================
class RoomsDialog(QDialog):
    def __init__(self, parent=None, initial_rooms: List[Dict[str, str]] | None = None):
        super().__init__(parent)
        self.setWindowTitle("Настройки помещений")
        self.resize(700, 450)

        self.spin = QSpinBox()
        self.spin.setRange(0, 100)
        self.spin.setValue(len(initial_rooms or []))
        self.spin.valueChanged.connect(self._on_count)

        self.tbl = SpreadsheetTable()
        self.tbl.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.tbl.setSelectionBehavior(QAbstractItemView.SelectItems)
        self.tbl.setEditTriggers(QAbstractItemView.AllEditTriggers)

        headers = [
            "Номер помещения", "Наименование", "Класс чистоты",
            "Площадь, м²", "Объём, м³", "Δдавл., Pa",
            "Расход, м³/ч", "Кратность, не менее", "Темп., °C", "RH, %"
        ]
        self.tbl.setColumnCount(len(headers))
        self.tbl.setHorizontalHeaderLabels(headers)

        self._on_count(self.spin.value())
        if initial_rooms:
            for r, data in enumerate(initial_rooms):
                for c, key in enumerate(
                    ["num", "name", "klass", "area", "volume",
                     "dp", "airflow", "exchange", "temp", "rh"]
                ):
                    self.tbl.setItem(r, c, QTableWidgetItem(data.get(key, "")))

        btn_ok = QPushButton("ОК")
        btn_cancel = QPushButton("Отмена")
        btn_ok.clicked.connect(self.accept)
        btn_cancel.clicked.connect(self.reject)

        hb = QHBoxLayout()
        hb.addStretch()
        hb.addWidget(btn_ok)
        hb.addWidget(btn_cancel)

        lay = QVBoxLayout(self)
        lay.addWidget(QLabel("Количество помещений:"))
        lay.addWidget(self.spin)
        lay.addWidget(self.tbl)
        lay.addLayout(hb)

    def _on_count(self, n: int) -> None:
        self.tbl.setRowCount(n)
        for r in range(n):
            for c in range(self.tbl.columnCount()):
                if not self.tbl.item(r, c):
                    self.tbl.setItem(r, c, QTableWidgetItem(""))

    def get_rooms(self) -> List[Dict[str, str]]:
        keys = ["num", "name", "klass", "area", "volume",
                "dp", "airflow", "exchange", "temp", "rh"]
        out: List[Dict[str, str]] = []
        for r in range(self.tbl.rowCount()):
            row: Dict[str, str] = {}
            for c, k in enumerate(keys):
                it = self.tbl.item(r, c)
                row[k] = (it.text().strip() if it else "")
            out.append(row)
        return out


class EquipmentDialog(QDialog):
    def __init__(self, parent=None, items_by_sheet: dict[str, list[dict]] | None = None):
        super().__init__(parent)
        self.setWindowTitle("Выбор оборудования")
        self.resize(600, 420)

        self.tabs = QTabWidget(self)
        self._lists: dict[str, QListWidget] = {}

        for sheet, items in (items_by_sheet or {}).items():
            lw = QListWidget()
            lw.setSelectionMode(QListWidget.MultiSelection)
            for it in items:
                item = QListWidgetItem(it.get("name_sn", ""))
                item.setData(Qt.UserRole, it)
                lw.addItem(item)
            self.tabs.addTab(lw, f"{sheet} ({len(items)})")
            self._lists[sheet] = lw

        btn_ok = QPushButton("ОК")
        btn_cancel = QPushButton("Отмена")
        btn_ok.clicked.connect(self.accept)
        btn_cancel.clicked.connect(self.reject)

        hb = QHBoxLayout()
        hb.addStretch()
        hb.addWidget(btn_ok)
        hb.addWidget(btn_cancel)

        lay = QVBoxLayout(self)
        lay.addWidget(self.tabs)
        lay.addLayout(hb)

    def get_selected(self) -> list[dict]:
        res: list[dict] = []
        for lw in self._lists.values():
            res.extend(i.data(Qt.UserRole) for i in lw.selectedItems())
        return res


class TestsDialog(QDialog):
    """Выбор тестов + кнопка калькулятора рядом с тестом 11."""
    def __init__(self, parent=None, items: List[str] | None = None,
                 selected: List[str] | None = None,
                 calc_launcher=None):
        super().__init__(parent)
        self.setWindowTitle("Выберите тесты")
        self.resize(600, 400)

        self.selection_order: List[int] = []
        self.calc_launcher = calc_launcher

        lay = QVBoxLayout(self)
        self.list = QListWidget(self)
        self.list.setSelectionMode(QAbstractItemView.MultiSelection)
        lay.addWidget(self.list)

        self._base_text_by_row: list[str] = []
        self._label_by_row: list[QLabel] = []

        rx_calc = re.compile(r"(?i)тест\s*11.*расход.*приточ", re.IGNORECASE)

        for txt in (items or []):
            item = QListWidgetItem()
            roww = QWidget()
            hb = QHBoxLayout(roww)
            hb.setContentsMargins(6, 2, 6, 2)

            lbl = QLabel(txt)
            hb.addWidget(lbl)
            hb.addStretch()

            if rx_calc.search(txt) and callable(self.calc_launcher):
                btn = QPushButton("Кальк.")
                btn.setToolTip("Открыть калькулятор Тест 11")
                btn.clicked.connect(self.calc_launcher)
                hb.addWidget(btn)

            self.list.addItem(item)
            self.list.setItemWidget(item, roww)
            item.setSizeHint(roww.sizeHint())

            self._base_text_by_row.append(txt)
            self._label_by_row.append(lbl)

        if selected:
            by_text = {t: i for i, t in enumerate(self._base_text_by_row)}
            for txt in selected:
                r = by_text.get(txt)
                if r is not None:
                    self.list.item(r).setSelected(True)
                    self.selection_order.append(r)

        btn_ok = QPushButton("ОК")
        btn_cancel = QPushButton("Отмена")
        btn_ok.clicked.connect(self.accept)
        btn_cancel.clicked.connect(self.reject)

        hb2 = QHBoxLayout()
        hb2.addStretch()
        hb2.addWidget(btn_ok)
        hb2.addWidget(btn_cancel)
        lay.addLayout(hb2)

        self.list.itemSelectionChanged.connect(self._on_selection_changed)
        self._renumber()

    def _on_selection_changed(self):
        current = {i.row() for i in self.list.selectedIndexes()}
        prev = set(self.selection_order)
        for r in list(self.selection_order):
            if r not in current:
                self.selection_order.remove(r)
        self.selection_order.extend(sorted(current - prev))
        self._renumber()

    def _renumber(self):
        for r, lbl in enumerate(self._label_by_row):
            lbl.setText(self._base_text_by_row[r])
        for n, r in enumerate(self.selection_order, start=1):
            lbl = self._label_by_row[r]
            base = self._base_text_by_row[r]
            lbl.setText(f"{n:02d}. {base}")

    def get_selected(self) -> List[str]:
        return [self._base_text_by_row[r] for r in self.selection_order]


# =============================================================================
# 6) Приложения 1/4: drag&drop + Ctrl+V
# =============================================================================
_ALLOWED_FILE_EXT = {".png", ".jpg", ".jpeg", ".bmp", ".tif", ".tiff", ".gif", ".pdf"}


class DropListWidget(QListWidget):
    def __init__(self, parent=None, *, paste_dir: Path | None = None, paste_prefix: str = "paste"):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)

        base = Path(paste_dir) if paste_dir else Path(tempfile.gettempdir()) / "doc_generator_app" / "pasted_images"
        base.mkdir(parents=True, exist_ok=True)
        self._paste_dir = base
        self._paste_prefix = paste_prefix

    def dragEnterEvent(self, e: QDragEnterEvent):
        if e.mimeData().hasUrls():
            e.acceptProposedAction()
        else:
            super().dragEnterEvent(e)

    def dragMoveEvent(self, e):
        if e.mimeData().hasUrls():
            e.acceptProposedAction()
        else:
            super().dragMoveEvent(e)

    def dropEvent(self, e: QDropEvent):
        if e.mimeData().hasUrls():
            paths: list[str] = []
            for url in e.mimeData().urls():
                p = url.toLocalFile()
                if not p:
                    continue
                ext = Path(p).suffix.lower()
                if ext in _ALLOWED_FILE_EXT and Path(p).exists():
                    paths.append(str(Path(p).resolve()))
            self._add_paths(paths)
            e.acceptProposedAction()
            return
        super().dropEvent(e)

    def keyPressEvent(self, e):
        if e.matches(QKeySequence.Paste):
            if self.paste_from_clipboard():
                return
        super().keyPressEvent(e)

    def paste_from_clipboard(self) -> bool:
        cb = QGuiApplication.clipboard()
        md = cb.mimeData()

        # 1) картинка (скриншот)
        if md.hasImage():
            img = cb.image()
            if img.isNull():
                return False

            fname = f"{self._paste_prefix}_{datetime.now():%Y%m%d_%H%M%S}_{uuid.uuid4().hex[:8]}.png"
            out = (self._paste_dir / fname).resolve()
            ok = img.save(str(out), "PNG")
            if not ok:
                return False

            self._add_paths([str(out)])
            return True

        # 2) файлы из проводника
        if md.hasUrls():
            paths: list[str] = []
            for url in md.urls():
                p = url.toLocalFile()
                if not p:
                    continue
                pp = Path(p)
                if pp.exists() and pp.suffix.lower() in _ALLOWED_FILE_EXT:
                    paths.append(str(pp.resolve()))
            if paths:
                self._add_paths(paths)
                return True

        return False

    def _add_paths(self, paths: list[str]):
        existing = set(self.get_paths())
        for p in paths:
            if p in existing:
                continue
            self.addItem(QListWidgetItem(p))
            existing.add(p)

    def get_paths(self) -> list[str]:
        return [self.item(i).text() for i in range(self.count())]


class AppendixImagesDialog(QDialog):
    def __init__(self, parent=None, title: str = "Загрузка изображений/скриншотов",
                 initial_paths: list[str] | None = None,
                 paste_prefix: str = "app"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.resize(760, 480)

        self.list = DropListWidget(self, paste_prefix=paste_prefix)
        if initial_paths:
            self.list._add_paths(initial_paths)

        # Ctrl+V на всё окно
        self._sc_paste = QShortcut(QKeySequence.Paste, self)
        self._sc_paste.activated.connect(self._on_paste)

        hint = QLabel(
            "Перетащите файлы сюда или нажмите «Добавить…».\n"
            "Также можно вставить скриншот: Ctrl+V.\n"
            "Поддержка: PNG/JPG/BMP/TIFF/GIF/PDF.\n"
            "Важно: PDF как картинку docxtpl вставлять не умеет — PDF будут пропущены."
        )
        hint.setWordWrap(True)

        btn_add = QPushButton("Добавить…")
        btn_rm = QPushButton("Удалить выбранные")
        btn_clear = QPushButton("Очистить")

        btn_add.clicked.connect(self._add_files)
        btn_rm.clicked.connect(self._remove_selected)
        btn_clear.clicked.connect(self.list.clear)

        hb = QHBoxLayout()
        hb.addWidget(btn_add)
        hb.addWidget(btn_rm)
        hb.addWidget(btn_clear)
        hb.addStretch()

        btn_ok = QPushButton("ОК")
        btn_cancel = QPushButton("Отмена")
        btn_ok.clicked.connect(self.accept)
        btn_cancel.clicked.connect(self.reject)

        hb2 = QHBoxLayout()
        hb2.addStretch()
        hb2.addWidget(btn_ok)
        hb2.addWidget(btn_cancel)

        lay = QVBoxLayout(self)
        lay.addWidget(hint)
        lay.addWidget(self.list)
        lay.addLayout(hb)
        lay.addLayout(hb2)

    def _on_paste(self):
        if not self.list.paste_from_clipboard():
            QApplication.beep()

    def _add_files(self):
        files, _ = QFileDialog.getOpenFileNames(
            self,
            "Выберите файлы",
            os.getcwd(),
            "Images/PDF (*.png *.jpg *.jpeg *.bmp *.tif *.tiff *.gif *.pdf)"
        )
        if files:
            self.list._add_paths([str(Path(f).resolve()) for f in files])

    def _remove_selected(self):
        for it in list(self.list.selectedItems()):
            row = self.list.row(it)
            self.list.takeItem(row)

    def get_paths(self) -> list[str]:
        return self.list.get_paths()


# =============================================================================
# 7) Автозаполнение "Тест 11.2. Проверка кратности воздухообмена в ЧП"
# =============================================================================
def _fill_test_112(doc: DocxDocument, rooms: List[Dict[str, Any]]):
    def norm(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip().lower()

    t112 = None
    for t in doc.tables:
        if not t.rows:
            continue
        head = " ".join(c.text for c in t.rows[0].cells)
        h = norm(head)
        if ("тест" in h and ("11.2" in h or "11,2" in h)) and ("кратност" in h or "чп" in h):
            t112 = t
            break
    if t112 is None:
        return

    hdr_cols_row_idx = None
    for i, row in enumerate(t112.rows):
        line = norm(" ".join(c.text for c in row.cells))
        if "результаты испытани" in line:
            hdr_cols_row_idx = i + 1 if (i + 1) < len(t112.rows) else None
            break
    if hdr_cols_row_idx is None:
        for i, row in enumerate(t112.rows):
            line = norm(" ".join(c.text for c in row.cells))
            if ("номер" in line and "объем" in line) or ("общий расход" in line):
                hdr_cols_row_idx = i
                break
    if hdr_cols_row_idx is None:
        return

    def find_col(cells, *needles):
        for ci, c in enumerate(cells):
            tt = norm(c.text)
            if all(n in tt for n in needles):
                return ci
        return None

    cols_row = t112.rows[hdr_cols_row_idx]
    col_total = find_col(cols_row.cells, "общий", "расход")
    col_fact = find_col(cols_row.cells, "фактическ")
    if col_total is None and col_fact is None:
        return

    def is_spacer(row):
        return all(norm(c.text) in ("", "¤") for c in row.cells)

    data_start = hdr_cols_row_idx + 2  # пропускаем вторую строку заголовка
    while data_start < len(t112.rows) and is_spacer(t112.rows[data_start]):
        data_start += 1

    data_end = len(t112.rows)
    for i in range(data_start, len(t112.rows)):
        first_cell = norm(t112.rows[i].cells[0].text)
        if first_cell.startswith("комментар"):
            data_end = i
            break
    if data_end <= data_start:
        return

    need = len(rooms)
    have = data_end - data_start
    if need > have:
        sample_tr = deepcopy(t112.rows[data_end - 1]._tr)
        for _ in range(need - have):
            t112._tbl.append(deepcopy(sample_tr))
        data_end = data_start + need

    for idx, room in enumerate(rooms):
        r = data_start + idx
        if r >= len(t112.rows):
            break
        row = t112.rows[r]
        total_flow = (room.get("total_flow") or "").strip()
        exch_act = (room.get("exchange_actual") or "").strip()

        if col_total is not None and col_total < len(row.cells) and total_flow:
            row.cells[col_total].text = total_flow
        if col_fact is not None and col_fact < len(row.cells) and exch_act:
            row.cells[col_fact].text = exch_act


# =============================================================================
# 8) Форматирование дат поверки в таблице оборудования
# =============================================================================
def _fix_weird_ddmmyyyy(s: str) -> str:
    # "26.062026" -> "26.06.2026"
    m = re.match(r"^(\d{1,2})\.(\d{2})(\d{4})$", s)
    if m:
        return f"{m.group(1)}.{m.group(2)}.{m.group(3)}"
    return s


def _parse_date_any(s: str):
    s = (s or "").strip().replace("\u00a0", " ")
    s = re.sub(r"\s+", " ", s).replace("г.", "").replace("г", "").strip(" .")
    if not s:
        return None

    s = s.split()[0]  # убрать время
    s = _fix_weird_ddmmyyyy(s)

    fmts = ["%Y-%m-%d", "%d.%m.%Y", "%d-%m-%Y", "%Y.%m.%d", "%d/%m/%Y", "%Y/%m/%d"]
    for fmt in fmts:
        try:
            return datetime.strptime(s, fmt).date()
        except Exception:
            pass

    m = re.match(r"^(\d{4})-(\d{1,2})-(\d{1,2})$", s)
    if m:
        try:
            return date(int(m.group(1)), int(m.group(2)), int(m.group(3)))
        except Exception:
            return None

    m = re.match(r"^(\d{1,2})\.(\d{1,2})\.(\d{4})$", s)
    if m:
        try:
            return date(int(m.group(3)), int(m.group(2)), int(m.group(1)))
        except Exception:
            return None

    return None


def _fmt_date(d: date) -> str:
    return d.strftime("%d.%m.%Y")


def _format_date_range_cell(text: str) -> str:
    if not text or not text.strip():
        return text

    raw = re.sub(r"\s*\n\s*", " ", text).strip()

    if "/" in raw:
        parts = [p.strip() for p in raw.split("/") if p.strip()]
        if len(parts) >= 2:
            d1 = _parse_date_any(parts[0])
            d2 = _parse_date_any(parts[1])
            if d1 and d2:
                return f"{_fmt_date(d1)} / {_fmt_date(d2)}"
            return raw

    date_like = re.findall(r"\d{4}-\d{1,2}-\d{1,2}|\d{1,2}\.\d{1,2}\.\d{4}|\d{1,2}\.\d{2}\d{4}", raw)
    if len(date_like) >= 2:
        d1 = _parse_date_any(date_like[0])
        d2 = _parse_date_any(date_like[1])
        if d1 and d2:
            return f"{_fmt_date(d1)} / {_fmt_date(d2)}"

    d = _parse_date_any(raw)
    if d:
        return _fmt_date(d)

    return raw


def postprocess_equipment_dates(doc: DocxDocument) -> None:
    """
    Ищет в документе столбец 'Дата поверки/ Действительно до:' и
    форматирует значения в 'ДД.ММ.ГГГГ / ДД.ММ.ГГГГ'.
    """
    def norm(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip().lower()

    hdr_needle = "дата поверки/ действительно до"
    for t in doc.tables:
        if not t.rows:
            continue

        hdr_row_idx = None
        for ri in range(min(3, len(t.rows))):
            row_text = " ".join(c.text for c in t.rows[ri].cells)
            if hdr_needle in norm(row_text):
                hdr_row_idx = ri
                break
        if hdr_row_idx is None:
            continue

        col_idx = None
        for ci, c in enumerate(t.rows[hdr_row_idx].cells):
            if hdr_needle in norm(c.text):
                col_idx = ci
                break
        if col_idx is None:
            continue

        for ri in range(hdr_row_idx + 1, len(t.rows)):
            cell = t.rows[ri].cells[col_idx]
            old = cell.text
            new = _format_date_range_cell(old)
            if new != old:
                cell.text = new


import time
import re
import win32com.client as win32
from logger import logger



import re
from typing import Optional

import win32com.client as win32
from logger import logger


import re
from copy import deepcopy
from typing import Optional

from docx.document import Document as DocxDocument
from docx.table import Table
from docx.oxml import OxmlElement
from docx.oxml.ns import qn


def _norm_basic(s: str) -> str:
    s = "" if s is None else str(s)
    s = (
        s.replace("\u00A0", " ")
         .replace("\u202F", " ")
         .replace("\u200B", "")
         .replace("\u00AD", "")
    )
    s = re.sub(r"\s+", " ", s).strip().lower()
    s = s.replace("ё", "е")
    return s


def _match_key(s: str) -> str:
    return re.sub(r"[^0-9a-zа-я]+", "", _norm_basic(s))


def _looks_like_table5(tbl: Table) -> bool:
    """
    Узнаём Таблицу 5 по шапке (стабильно для ваших шаблонов):
      - в первых 2 строках должны встречаться "Риск", "Возможная причина"
      - и "Аттестационное испытание"
    """
    if not tbl.rows:
        return False

    head0 = " ".join(_norm_basic(c.text) for c in tbl.rows[0].cells)
    head1 = " ".join(_norm_basic(c.text) for c in tbl.rows[1].cells) if len(tbl.rows) > 1 else ""

    return (
        ("риск" in head0 or "риск" in head1)
        and ("возможная причина" in head0 or "возможная причина" in head1)
        and ("аттестационное испытание" in head0 or "аттестационное испытание" in head1)
    )


def _insert_page_break_paragraph_after_table(tbl: Table) -> OxmlElement:
    """
    Вставляет ПУСТОЙ абзац с разрывом страницы СРАЗУ после таблицы.
    """
    p = OxmlElement("w:p")
    r = OxmlElement("w:r")
    br = OxmlElement("w:br")
    br.set(qn("w:type"), "page")
    r.append(br)
    p.append(r)
    tbl._tbl.addnext(p)
    return p


def _insert_bold_tnr_paragraph_after(el: OxmlElement, text: str) -> OxmlElement:
    """
    Вставляет абзац сразу после el:
      - Times New Roman
      - 12pt
      - bold
      - текст: text
    """
    p = OxmlElement("w:p")
    r = OxmlElement("w:r")
    rPr = OxmlElement("w:rPr")

    rFonts = OxmlElement("w:rFonts")
    for a in ("ascii", "hAnsi", "cs", "eastAsia"):
        rFonts.set(qn(f"w:{a}"), "Times New Roman")
    rPr.append(rFonts)

    b = OxmlElement("w:b")
    rPr.append(b)

    # 12pt = 24 half-points
    sz = OxmlElement("w:sz")
    sz.set(qn("w:val"), "24")
    rPr.append(sz)

    szCs = OxmlElement("w:szCs")
    szCs.set(qn("w:val"), "24")
    rPr.append(szCs)

    r.append(rPr)

    t = OxmlElement("w:t")
    t.text = text
    r.append(t)

    p.append(r)
    el.addnext(p)
    return p


def split_table5_with_continuation_open_doc(
    doc: DocxDocument,
    *,
    split_risk_phrase: str = "Класс чистоты ЧП не соответствует установленным требованиям",
    continuation_title: str = "Продолжение таблицы 5",
    header_rows_count: int = 2,
) -> bool:
    """
    Делает разделение Таблицы 5 на 2 таблицы, как в "правильном шаблоне":

    - Находит Таблицу 5 по шапке (Риск / Возможная причина / Аттестационное испытание).
    - Находит строку, где в 1-й колонке встречается split_risk_phrase.
    - Всё начиная с этой строки переносит в НОВУЮ таблицу (копией XML),
      при этом шапка (header_rows_count) остаётся и в первой, и во второй таблице.
    - Между таблицами вставляет:
        1) разрыв страницы
        2) абзац "Продолжение таблицы 5" (TNR 12 bold)
    - Ничего не "перерисовывает" — копирует XML => формат ЕДИНЫЙ 1:1.

    Возвращает True если разделение сделано, иначе False.
    """

    # 1) Найти Таблицу 5
    t5: Optional[Table] = None
    for t in doc.tables:
        if _looks_like_table5(t):
            t5 = t
            break
    if t5 is None:
        return False

    # 2) Если уже есть "Продолжение таблицы 5" где-то в документе — не плодим дубль
    if any(continuation_title in (p.text or "") for p in doc.paragraphs):
        return False

    if len(t5.rows) <= header_rows_count:
        return False

    # 3) Найти row-индекс (внутри t5), с которого нужно переносить во 2-ю таблицу
    target_key = _match_key(split_risk_phrase)
    split_row_idx = None
    for ri in range(header_rows_count, len(t5.rows)):
        c0 = t5.rows[ri].cells[0].text
        if target_key and target_key in _match_key(c0):
            split_row_idx = ri
            break

    # Если фразы нет — НЕ делим (как ты и просишь: делим именно там)
    if split_row_idx is None:
        return False

    # Если попали прямо в начало данных — тоже смысла делить нет
    if split_row_idx <= header_rows_count:
        return False

    # 4) Достаём XML-строки
    tbl_el = t5._tbl
    tr_elems = tbl_el.xpath("./w:tr")
    if len(tr_elems) != len(t5.rows):
        # крайне редкая ситуация, но если вдруг — не рискуем
        return False

    header_trs = tr_elems[:header_rows_count]
    data_trs = tr_elems[header_rows_count:]

    split_data_pos = split_row_idx - header_rows_count
    if not (0 < split_data_pos < len(data_trs)):
        return False

    # 5) Создаём новую таблицу как полную копию, затем чистим строки
    new_tbl_el = deepcopy(tbl_el)
    new_tr_elems = new_tbl_el.xpath("./w:tr")

    # В новой таблице оставляем: header + data[split:]
    keep_idxs_new = set(range(0, header_rows_count)) | set(
        range(header_rows_count + split_data_pos, header_rows_count + len(data_trs))
    )
    for i in range(len(new_tr_elems) - 1, -1, -1):
        if i not in keep_idxs_new:
            new_tbl_el.remove(new_tr_elems[i])

    # В старой (первой) таблице оставляем: header + data[:split]
    for i in range(len(tr_elems) - 1, -1, -1):
        if i >= header_rows_count + split_data_pos:
            tbl_el.remove(tr_elems[i])

    # 6) Вставляем: разрыв страницы + "Продолжение..." + новую таблицу
    p_break = _insert_page_break_paragraph_after_table(t5)
    p_title = _insert_bold_tnr_paragraph_after(p_break, continuation_title)
    p_title.addnext(new_tbl_el)

    return True




def update_fields_with_word(docx_path: str) -> None:
    """
    Открывает DOCX в Word, режет Таблицу 5, обновляет поля/колонтитулы, сохраняет.
    """
    word = win32.gencache.EnsureDispatch("Word.Application")
    word.Visible = False
    try:
        doc = word.Documents.Open(str(docx_path))

        doc.Repaginate()
        split_table5_with_continuation_open_doc(doc)
        doc.Repaginate()

        doc.Fields.Update()
        for sec in doc.Sections:
            sec.Headers(1).Range.Fields.Update()
            sec.Footers(1).Range.Fields.Update()

        doc.Save()
        doc.Close()
    finally:
        word.Quit()

def _set_cell_text_keep_style(cell, text: str) -> None:
    """
    Ставит текст, стараясь не ломать форматирование ячейки:
    - если есть runs, пишем в первый run и чистим остальные
    - иначе fallback на cell.text
    """
    text = "" if text is None else str(text)

    if cell.paragraphs:
        p0 = cell.paragraphs[0]
        if p0.runs:
            p0.runs[0].text = text
            for r in p0.runs[1:]:
                r.text = ""
            # чистим остальные параграфы в ячейке
            for p in cell.paragraphs[1:]:
                for r in p.runs:
                    r.text = ""
            return

    cell.text = text


from copy import deepcopy
import re
from pathlib import Path
import openpyxl
from docx.table import Table
from docx.document import Document as DocxDocument


def _norm_key(s: str) -> str:
    s = "" if s is None else str(s)
    s = re.sub(r"(?i)^\s*тест\s*\d+(?:[.,]\d+)?\.?\s*", "", s).strip()
    s = (
        s.replace("\u00A0", " ")
         .replace("\u202F", " ")
         .replace("\u200B", "")
         .replace("\u00AD", "")
    )
    s = re.sub(r"\s+", " ", s).strip().lower()
    s = s.replace("ё", "е")
    # ключ без знаков
    return re.sub(r"[^0-9a-zа-я]+", "", s)


def _set_cell_text_keep_style(cell, text: str) -> None:
    text = "" if text is None else str(text)

    if cell.paragraphs:
        p0 = cell.paragraphs[0]
        if p0.runs:
            p0.runs[0].text = text
            for r in p0.runs[1:]:
                r.text = ""
            for p in cell.paragraphs[1:]:
                for r in p.runs:
                    r.text = ""
            return

    cell.text = text


def _load_table2_rows_from_excel(xlsx_path: str, sheet_name: str | None = None) -> dict[str, dict]:
    """
    Возвращает словарь:
      norm(test_name) -> {"test":..., "crit":..., "fact":..., "eval":...}
    """
    wb = openpyxl.load_workbook(xlsx_path, data_only=True)
    ws = wb[sheet_name] if sheet_name and sheet_name in wb.sheetnames else wb[wb.sheetnames[0]]

    # ожидаем шапку в первой строке
    # A: тест, B: критерий, C: факт, D: оценка
    out: dict[str, dict] = {}
    for r in range(2, ws.max_row + 1):
        test = ws.cell(r, 1).value
        crit = ws.cell(r, 2).value
        fact = ws.cell(r, 3).value
        evl  = ws.cell(r, 4).value

        if not test:
            continue

        row = {
            "test": str(test).strip(),
            "crit": "" if crit is None else str(crit).strip(),
            "fact": "" if fact is None else str(fact).strip(),
            "eval": "" if evl  is None else str(evl).strip(),
        }
        out[_norm_key(row["test"])] = row

    return out


def fill_report_table2_from_excel(
    doc: DocxDocument,
    selected_tests: list[str],
    xlsx_path: str,
    *,
    sheet_name: str | None = None,
    default_eval: str = "Соответствует",
) -> tuple[bool, list[str]]:
    """
    Заполняет Таблицу 2 в ОТЧ-OQ данными из Excel по выбранным тестам.
    Возвращает: (ok, missing_tests)
    """

    # 1) грузим Excel
    rows_map = _load_table2_rows_from_excel(xlsx_path, sheet_name=sheet_name)

    # 2) находим таблицу 2 (по заголовку столбцов)
    def norm(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip().lower()

    target_table: Table | None = None
    for t in doc.tables:
        if not t.rows:
            continue
        head = " ".join(c.text for c in t.rows[0].cells)
        h = norm(head)
        if ("тест" in h) and ("критер" in h) and ("фактичес" in h) and ("оценк" in h):
            target_table = t
            break

    if target_table is None:
        return False, selected_tests[:]  # не нашли таблицу

    # 3) ищем шаблонную строку с маркерами (лучший вариант)
    token_row_idx = None
    tokens = {"#T2_TEST", "#T2_CRIT", "#T2_FACT", "#T2_EVAL"}
    for ri, row in enumerate(target_table.rows):
        row_tokens = { (c.text or "").strip() for c in row.cells }
        if tokens.issubset(row_tokens):
            token_row_idx = ri
            break

    # если шаблонной строки нет:
    # - если есть хотя бы 2 строки, возьмем 2ю как базовую
    # - иначе создадим строку через add_row (стиль может быть не идеальный)
    if token_row_idx is None:
        if len(target_table.rows) >= 2:
            token_row_idx = 1
        else:
            target_table.add_row()
            token_row_idx = 1

    base_tr = deepcopy(target_table.rows[token_row_idx]._tr)

    # 4) готовим данные в порядке выбора пользователя
    missing: list[str] = []
    chosen_rows: list[dict] = []
    for tname in selected_tests:
        key = _norm_key(tname)
        row = rows_map.get(key)
        if not row:
            missing.append(tname)
            # можно пропускать, либо вставлять пустую строку — выберу пропуск
            continue
        chosen_rows.append(row)

    # если ничего не нашли — хотя бы очистим шаблонную строку
    need = max(1, len(chosen_rows))

    # сколько строк данных сейчас начиная с token_row_idx
    have = len(target_table.rows) - token_row_idx
    if need > have:
        for _ in range(need - have):
            target_table._tbl.append(deepcopy(base_tr))

    # 5) заполняем строки
    for i in range(need):
        row = target_table.rows[token_row_idx + i]
        data = chosen_rows[i] if i < len(chosen_rows) else {"test": "", "crit": "", "fact": "", "eval": ""}

        for cell in row.cells:
            token = (cell.text or "").strip()

            if token == "#T2_TEST":
                _set_cell_text_keep_style(cell, data.get("test", ""))
            elif token == "#T2_CRIT":
                _set_cell_text_keep_style(cell, data.get("crit", ""))
            elif token == "#T2_FACT":
                _set_cell_text_keep_style(cell, data.get("fact", ""))
            elif token == "#T2_EVAL":
                ev = data.get("eval", "").strip() or default_eval
                _set_cell_text_keep_style(cell, ev)
            else:
                # если маркеров нет (fallback-режим), попробуем по колонкам
                # (тут можно оставить как есть)
                pass

    return True, missing


def fill_report_table1_rooms_by_hashes(doc: DocxDocument, rooms: list[dict]) -> bool:
    """
    Ищет таблицу, где строка данных содержит маркеры:
      #, ##, ###, ####, #$, #$$, #$$$, #%, #%%, #%%%
    и заполняет её из rooms (num, name, klass, area, volume, dp, airflow, exchange, temp, rh).
    """
    token_to_key = {
        "#": "num",
        "##": "name",
        "###": "klass",
        "####": "area",
        "#$": "volume",
        "#$$": "dp",
        "#$$$": "airflow",
        "#%": "exchange",
        "#%%": "temp",
        "#%%%": "rh",
    }

    target_table = None
    tmpl_row_idx = None

    # 1) найти таблицу и "шаблонную" строку с #..#%%%
    for t in doc.tables:
        for ri, row in enumerate(t.rows):
            row_tokens = [c.text.strip() for c in row.cells]
            if ("#" in row_tokens) and ("##" in row_tokens) and ("#%%%" in row_tokens):
                target_table = t
                tmpl_row_idx = ri
                break
        if target_table:
            break

    if not target_table or tmpl_row_idx is None:
        return False

    # 2) копируем шаблонную строку (чтобы формат 1:1 сохранялся)
    base_tr = deepcopy(target_table.rows[tmpl_row_idx]._tr)

    need = max(1, len(rooms))  # если комнат 0 — оставим одну строку пустой
    have = len(target_table.rows) - tmpl_row_idx

    if need > have:
        for _ in range(need - have):
            target_table._tbl.append(deepcopy(base_tr))

    # 3) заполняем
    for i in range(need):
        row = target_table.rows[tmpl_row_idx + i]
        room = rooms[i] if i < len(rooms) else {}

        for cell in row.cells:
            token = (cell.text or "").strip()
            key = token_to_key.get(token)
            if not key:
                continue
            _set_cell_text_keep_style(cell, (room.get(key) or "").strip())

    return True

def fix_table2_caption_glue(doc: DocxDocument, caption: str = "Таблица 2") -> bool:
    """
    1) Удаляет пустые абзацы между подписью и таблицей
    2) Делает таблицу inline (убирает tblpPr/tblOverlap)
    3) КЛЮЧЕВОЕ: ставит keepNext на абзац подписи, чтобы Word не оставлял подпись сиротой
    """
    from docx.oxml.ns import qn
    from docx.oxml import OxmlElement

    def norm(s: str) -> str:
        s = (s or "").replace("\u00A0", " ")
        s = re.sub(r"\s+", " ", s).strip().lower()
        return s

    cap_p = None
    for p in doc.paragraphs:
        if norm(p.text) == norm(caption):
            cap_p = p
            break
    if cap_p is None:
        return False

    # ✅ Главное: подпись не должна отрываться от таблицы
    pf = cap_p.paragraph_format
    pf.keep_with_next = True
    pf.keep_together = True
    pf.widow_control = True

    def norm(s: str) -> str:
        s = (s or "").replace("\u00A0", " ")
        s = re.sub(r"\s+", " ", s).strip().lower()
        return s

    # 0) найти абзац подписи
    cap_p = None
    for p in doc.paragraphs:
        if norm(p.text) == norm(caption):
            cap_p = p
            break
    if cap_p is None:
        return False

    # 1) keepNext на подпись (чтобы не отрывалась от таблицы)
    pPr = cap_p._p.get_or_add_pPr()
    if pPr.find(qn("w:keepNext")) is None:
        pPr.append(OxmlElement("w:keepNext"))

    # (опционально) чуть безопаснее: не разрывать саму подпись
    if pPr.find(qn("w:keepLines")) is None:
        pPr.append(OxmlElement("w:keepLines"))

    # 2) найти следующий элемент и удалить пустые абзацы между подписью и таблицей
    p_el = cap_p._p
    sib = p_el.getnext()

    while sib is not None and sib.tag != qn("w:tbl"):
        if sib.tag == qn("w:p"):
            # удаляем реально пустые (в т.ч. с одними пробелами)
            txt = "".join(t.text for t in sib.iter() if t.tag == qn("w:t"))
            if norm(txt) == "":
                nxt = sib.getnext()
                sib.getparent().remove(sib)
                sib = nxt
                continue
        sib = sib.getnext()

    if sib is None or sib.tag != qn("w:tbl"):
        return False

    # 3) убрать "плавающее" позиционирование таблицы
    tbl_el = sib
    tblPr = tbl_el.find(qn("w:tblPr"))
    if tblPr is not None:
        for child_tag in (qn("w:tblpPr"), qn("w:tblOverlap")):
            ch = tblPr.find(child_tag)
            if ch is not None:
                tblPr.remove(ch)

    return True




# =============================================================================
# 9) Render Worker
# =============================================================================

class RenderWorker(QThread):
    progress = Signal(int, str)
    finished = Signal(bool, str, list)

    def __init__(
            self,
            tpl_path: str,
            tests_doc_path: str,
            xls_tests_path: str,
            xls_eq_path: str,
            out_path: str,
            selected_tests: list[str],
            rooms: list[dict],
            equipment: list[dict],
            ctx_fields: dict,
            *,
            risk_path: str,
            scans_dir: str,
            app1_images: list[str],
            app4_images: list[str],
            app5_images: list[str],

            # NEW:
            tpl_report_path: str | None = None,
            out_report_path: str | None = None,
            ctx_fields_report: dict | None = None,
            xls_report_path: str | None = None,
            report_code: str | None = None,  # <-- ДОБАВИЛИ
    ):
        super().__init__()

        self.tpl_path = tpl_path
        self.xls_report_path = xls_report_path
        self.tests_doc_path = tests_doc_path
        self.xls_tests_path = xls_tests_path
        self.xls_eq_path = xls_eq_path
        self.out_path = out_path
        self.selected_tests = selected_tests
        self.rooms = rooms
        self.equipment = equipment
        self.ctx_fields = ctx_fields
        self.risk_path = risk_path
        self.scans_dir = scans_dir
        self.app1_images = app1_images or []
        self.app4_images = app4_images or []
        self.app5_images = app5_images or []

        self.tpl_report_path = tpl_report_path
        self.out_report_path = out_report_path
        self.ctx_fields_report = ctx_fields_report

        self.report_code = (report_code or "").upper()  # <-- ДОБАВИЛИ

    def run(self):
        missing: list[str] = []
        try:
            step = 0
            self.progress.emit(step, "Валидация файлов…")
            io_manager.validate_file(Path(self.tpl_path))
            io_manager.validate_file(Path(self.tests_doc_path))
            io_manager.validate_file(Path(self.xls_tests_path))
            io_manager.validate_file(Path(self.xls_eq_path))
            io_manager.validate_file(Path(self.risk_path))
            Path(self.out_path).parent.mkdir(parents=True, exist_ok=True)

            # второй документ (ОТЧ-<code>) — опционально
            do_report = bool(self.tpl_report_path and self.out_report_path and self.ctx_fields_report is not None)
            if do_report:
                io_manager.validate_file(Path(self.tpl_report_path))
                Path(self.out_report_path).parent.mkdir(parents=True, exist_ok=True)

                if self.xls_report_path:
                    io_manager.validate_file(Path(self.xls_report_path))
                else:
                    logger.warning(
                        f"ОТЧ-{getattr(self, 'report_code', '')}: не указан Excel-файл с данными для Таблицы 2.")
            else:
                # если отчёт не включен, report_code может быть пустым — это норм
                pass

            # ---------- 1. Базовый контекст ----------
            step += 1
            self.progress.emit(step, "Сбор контекста…")
            context = template_renderer.build_context(self.ctx_fields, self.rooms)

            # ---------- 2. Скан-файлы (поверки оборудования) ----------
            step += 1
            self.progress.emit(step, "Сбор сканов оборудования…")
            scan_paths: list[str] = []

            def _serial_key(s: str) -> str:
                return re.sub(r"[^0-9a-zA-Z]+", "", (s or "")).lower()

            if self.equipment and self.scans_dir:
                for eq in self.equipment:
                    name_sn = eq.get("name_sn", "")
                    try:
                        _, serial = [p.strip() for p in name_sn.rsplit(",", 1)]
                    except ValueError:
                        serial = name_sn.strip()

                    key = _serial_key(serial)
                    found = None
                    for root, _, files in os.walk(self.scans_dir):
                        for fn in files:
                            # pdf пропускаем как картинку (InlineImage не умеет PDF)
                            if Path(fn).suffix.lower() not in (".jpg", ".jpeg", ".png", ".pdf"):
                                continue
                            if _serial_key(Path(fn).stem) == key:
                                found = os.path.join(root, fn)
                                break
                        if found:
                            scan_paths.append(found)
                            break

            if scan_paths:
                context["Scan_paths"] = scan_paths

            # ---------- 3. Рендер тестового DOCX (1-й проход) ----------
            step += 1
            self.progress.emit(step, "Рендер тестового документа…")
            tpl_tests = DocxTemplate(self.tests_doc_path)
            tpl_tests.render(context)

            with temp_docx() as tmp_tests_path:
                tpl_tests.save(tmp_tests_path)

                # ---------- 4. Извлечь расход и посчитать кратность ----------
                tests_doc_parsed = Document(tmp_tests_path)

                def _robust_extract_total_flows_from_test11(docx_doc: DocxDocument):
                    flows: list[Decimal | None] = []

                    def norm(s: str) -> str:
                        return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip().lower()

                    def to_dec(s: str) -> Decimal | None:
                        s = (s or "").strip().replace("\u00a0", "").replace(" ", "").replace(",", ".")
                        try:
                            return Decimal(s)
                        except InvalidOperation:
                            return None

                    for t in docx_doc.tables:
                        head = " ".join(c.text for c in t.rows[0].cells) if t.rows else ""
                        h = norm(head)
                        if "проверка" in h and "расхода" in h and "приточ" in h:
                            hdr_idx = None
                            for i, row in enumerate(t.rows):
                                if "результаты испытани" in norm(" ".join(c.text for c in row.cells)):
                                    hdr_idx = i + 1 if (i + 1) < len(t.rows) else None
                                    break
                            if hdr_idx is None:
                                continue

                            rows_for_header = [t.rows[hdr_idx]]
                            if hdr_idx + 1 < len(t.rows):
                                rows_for_header.append(t.rows[hdr_idx + 1])

                            def col_idx(*needles):
                                for row in rows_for_header:
                                    for ci, c in enumerate(row.cells):
                                        tt = norm(c.text)
                                        if all(n in tt for n in needles):
                                            return ci
                                return None

                            col_fact = col_idx("фактическ")
                            col_sum = col_idx("фактическ", "суммарн")

                            cur_sum: Decimal | None = None
                            room_started = False

                            data_start = hdr_idx + (2 if len(rows_for_header) == 2 else 1)

                            for r in range(data_start, len(t.rows)):
                                row = t.rows[r]
                                row_text = norm(" ".join(c.text for c in row.cells))

                                if row_text.startswith("комментар"):
                                    if room_started:
                                        flows.append(cur_sum)
                                    break

                                if row_text.startswith("помещение"):
                                    if room_started:
                                        flows.append(cur_sum)
                                    room_started = True
                                    cur_sum = None
                                    continue

                                if not room_started:
                                    continue

                                if col_sum is not None and col_sum < len(row.cells):
                                    v = to_dec(row.cells[col_sum].text)
                                    if v is not None:
                                        cur_sum = v
                                        continue

                                if col_fact is not None and col_fact < len(row.cells):
                                    v = to_dec(row.cells[col_fact].text)
                                    if v is not None:
                                        cur_sum = (cur_sum or Decimal("0")) + v

                            if room_started:
                                flows.append(cur_sum)

                    return flows

                _total1 = table_processor.extract_total_flows_from_test11(tests_doc_parsed)
                total_flows = (
                    _total1 if (_total1 and any(v is not None for v in _total1))
                    else _robust_extract_total_flows_from_test11(tests_doc_parsed)
                )

                for idx, room in enumerate(self.rooms):
                    if idx < len(total_flows) and total_flows[idx] is not None:
                        val = total_flows[idx].quantize(Decimal("1.00"))
                        room["total_flow"] = f"{val}".replace(".", ",")
                    else:
                        pr = (room.get("airflow") or "").strip().replace(" ", "").replace("\u00a0", "")
                        pr = pr.replace(".", ",")
                        try:
                            q = Decimal(pr.replace(",", ".")).quantize(Decimal("1.00"))
                            room["total_flow"] = f"{q}".replace(".", ",")
                        except InvalidOperation:
                            room["total_flow"] = pr or ""

                    vol_raw = (room.get("volume") or "").replace(",", ".")
                    try:
                        vol = Decimal(vol_raw)
                        tf_raw = (room.get("total_flow") or "").replace(",", ".")
                        tf = Decimal(tf_raw) if tf_raw else None
                        if vol and vol > 0 and tf is not None:
                            exch = tf / vol
                            room["exchange_actual"] = str(exch.quantize(Decimal("1.00"))).replace(".", ",")
                        else:
                            room["exchange_actual"] = ""
                    except (InvalidOperation, ZeroDivisionError):
                        room["exchange_actual"] = ""

                # ---------- 5. Пересобрать контекст ----------
                context = template_renderer.build_context(self.ctx_fields, self.rooms)
                if scan_paths:
                    context["Scan_paths"] = scan_paths

                # ---------- 6. Перерендер тестового DOCX (2-й проход) ----------
                step += 1
                self.progress.emit(step, "Перерендер тестовых таблиц с расчётами…")
                tpl_tests2 = DocxTemplate(self.tests_doc_path)
                tpl_tests2.render(context)
                tpl_tests2.save(tmp_tests_path)

                # ---------- 7. Рендер основного шаблона ----------
                step += 1
                self.progress.emit(step, "Рендер основного шаблона…")
                tpl_main = DocxTemplate(self.tpl_path)

                context["App1Scans"] = make_inline_images(tpl_main, self.app1_images, label="Приложение 1")
                context["App4Scans"] = make_inline_images(tpl_main, self.app4_images, label="Приложение 4")
                context["App5Scans"] = make_inline_images(tpl_main, self.app5_images, label="Приложение 5")
                context["Scans"] = make_inline_images(tpl_main, scan_paths, label="Приложение 2")

                tpl_main.render(context)

                with temp_docx() as tmp_main_path:
                    tpl_main.save(tmp_main_path)
                    doc = Document(tmp_main_path)

                    # ---------- 8. Таблицы помещений/оборудования ----------
                    step += 1
                    self.progress.emit(step, "Обработка таблицы помещений…")
                    table_processor.process_rooms_table(doc, self.rooms)

                    step += 1
                    self.progress.emit(step, "Обработка таблицы оборудования…")
                    table_processor.process_equipment_table(doc, self.equipment)
                    postprocess_equipment_dates(doc)

                    # ---------- 9. Вставка выбранных тестов ----------
                    step += 1
                    self.progress.emit(step, "Вставка тестовых таблиц…")
                    missing = table_processor.insert_test_tables(doc, tmp_tests_path, self.selected_tests)

                    # ---------- 10. Таблица 5 ----------
                    step += 1
                    self.progress.emit(step, "Вставка Таблицы 5 (анализ рисков)…")
                    try:
                        risk_rows = get_risk_rows(self.risk_path, self.selected_tests)
                        insert_table5_into_doc(doc, risk_rows)
                    except Exception as e:
                        logger.warning(f"Таблица 5 не вставлена: {e}")

                    # ---------- 11. Постобработка ----------
                    step += 1
                    self.progress.emit(step, "Заполнение результатов тестов…")
                    table_processor.process_test_results_tables(doc, self.rooms)
                    _fill_test_112(doc, self.rooms)

                    import word_repeat_headers
                    word_repeat_headers.split_test_results_table(
                        doc,
                        split_phrase="Результаты испытания",
                        header_rows=2,
                        table_must_contain="Проверка расхода приточного воздуха",
                    )

                    step += 1
                    self.progress.emit(step, "Унификация шрифта…")
                    table_processor.enforce_tnr_face_only_everywhere(doc)

                    try:
                        for table in doc.tables:
                            table.style = "Table Grid"
                    except Exception as e:
                        logger.warning(f"Не удалось применить стиль 'Table Grid': {e}")

                    # ---------- 12. Сохранение основного документа ----------
                    step += 1
                    self.progress.emit(step, "Сохранение…")
                    doc.save(self.out_path)

                # обновление полей/колонтитулов + разрезание таблицы 5 через Word (если нужно)
                try:
                    word_table5_splitter.update_fields_with_word(self.out_path)
                except Exception as e:
                    logger.warning(f"Не удалось обновить поля/разрезать таблицу 5 через Word: {e}")

                # ---------- 13. Рендер ОТЧ-<code> ----------
                if do_report:
                    rep = (getattr(self, "report_code", "") or "").upper()
                    rep = rep if rep else "ОТЧ"

                    step += 1
                    self.progress.emit(step, f"Рендер {rep}…")

                    context_r = template_renderer.build_context(self.ctx_fields_report, self.rooms)
                    if scan_paths:
                        context_r["Scan_paths"] = scan_paths

                    tpl_r = DocxTemplate(self.tpl_report_path)

                    context_r["App1Scans"] = make_inline_images(tpl_r, self.app1_images, label="Приложение 1")
                    context_r["App4Scans"] = make_inline_images(tpl_r, self.app4_images, label="Приложение 4")
                    context_r["App5Scans"] = make_inline_images(tpl_r, self.app5_images, label="Приложение 5")
                    context_r["Scans"] = make_inline_images(tpl_r, scan_paths, label="Приложение 2")

                    tpl_r.render(context_r)

                    with temp_docx() as tmp_r_path:
                        tpl_r.save(tmp_r_path)
                        doc_r = Document(tmp_r_path)

                        # 1) Таблица 1 (помещения)
                        ok1 = fill_report_table1_rooms_by_hashes(doc_r, self.rooms)
                        if not ok1:
                            logger.warning(
                                f"{rep}: Таблица 1 с маркерами #/##/... не найдена — помещения не заполнены.")

                        # 2) Таблица 2 (из Excel по выбранным тестам)
                        if self.xls_report_path:
                            ok2, missing2 = fill_report_table2_from_excel(
                                doc_r,
                                self.selected_tests,  # порядок как выбран пользователем
                                self.xls_report_path,
                                default_eval="Соответствует",
                            )
                            if not ok2:
                                logger.warning(f"{rep}: Таблица 2 не найдена (по заголовку/маркерам).")
                            if missing2:
                                logger.warning(f"{rep}: в Excel нет строк для тестов:\n" + "\n".join(missing2))
                        else:
                            logger.warning(f"{rep}: Excel отчёта не задан — Таблица 2 не заполнена.")

                        # 3) "Таблица 2" приклеить к следующей таблице
                        try:
                            fix_table2_caption_glue(doc_r)
                        except Exception as e:
                            logger.warning(f"{rep}: не удалось применить fix_table2_caption_glue: {e}")

                        # 4) Сохранение
                        doc_r.save(self.out_report_path)

                    # Таблица 2: деление по странице + "Продолжение таблицы 2" + обновление полей
                    try:
                        word_table2_otch_splitter.update_fields_and_split_table2(self.out_report_path)
                    except Exception as e:
                        logger.warning(f"{rep}: не удалось разрезать Таблицу 2 / обновить поля через Word: {e}")

                    # финальный проход: обновить ВСЁ (PAGE/NUMPAGES + TOC + поля)
                    try:
                        import word_update_all
                        word_update_all.update_all(self.out_report_path)
                    except Exception as e:
                        logger.warning(f"{rep}: не удалось обновить все поля/содержание через Word: {e}")

                msg = f"Документ сохранён:\n{self.out_path}"
                if do_report and self.out_report_path:
                    rep = (getattr(self, "report_code", "") or "").upper()
                    rep = f"ОТЧ-{rep}" if rep else "ОТЧ"
                    msg += f"\n\n{rep} сохранён:\n{self.out_report_path}"

                self.finished.emit(True, msg, missing)

        except Exception as e:
            logger.exception("Ошибка в RenderWorker:")
            self.finished.emit(False, str(e), [])


# =============================================================================
# 10) Main Window
# =============================================================================
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Генератор OQ/PQ — PySide6 + DocxTemplate")

        base = Path(__file__).resolve().parents[1]
        self.defaults = {
            "OQ": {
                "tpl": base / "Шаблон OQ.docx",
                "tests": base / "Тесты OQ.docx",
                "xls_tests": base / "tests OQ.xlsx",
                "xls_eq": base / "ПЕРЕЧЕНЬ ПРИБОРОВ OQ.xlsx",
                "scans_dir": base / "Сканы поверок",
                "risk_doc": base / "risk_analysis_from_docx.xlsx",
            },
            "PQ": {
                "tpl": base / "Шаблон PQ.docx",
                "tests": base / "Тесты PQ.docx",
                "xls_tests": base / "tests PQ.xlsx",
                "xls_eq": base / "ПЕРЕЧЕНЬ ПРИБОРОВ OQ.xlsx",
                "scans_dir": base / "Сканы поверок",
                "risk_doc": base / "risk_analysis_from_docx.xlsx",
            },
        }

        self.rooms: List[Dict[str, str]] = []
        self.equipment: List[Dict[str, str]] = []
        self.all_tests: List[str] = []
        self.selected_tests: List[str] = []
        self._batch_modes: List[str] = []

        # Приложения 1, 4, 5
        self.app1_images: list[str] = []
        self.app4_images: list[str] = []
        self.app5_images: list[str] = []

        self._build_ui()
        self.on_mode_changed("OQ")

    def _build_ui(self) -> None:
        cw = QWidget()
        g = QGridLayout()
        g.setSpacing(10)
        row = 0

        g.addWidget(QLabel("Режим:"), row, 0)
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(["OQ", "PQ", "OQ и PQ"])
        self.mode_combo.currentTextChanged.connect(self.on_mode_changed)
        g.addWidget(self.mode_combo, row, 1, 1, 2)
        row += 1

        g.addWidget(QLabel("Шаблон (.docx):"), row, 0)
        self.tpl_path = QLineEdit()
        self.tpl_path.setReadOnly(True)
        g.addWidget(self.tpl_path, row, 1, 1, 1)
        btn_browse_tpl = QPushButton("…")
        btn_browse_tpl.clicked.connect(lambda: self._select(self.tpl_path, "Word Documents (*.docx)", save=False))
        g.addWidget(btn_browse_tpl, row, 2)
        row += 1

        g.addWidget(QLabel("Документ-тесты (.docx):"), row, 0)
        self.tests_path = QLineEdit()
        g.addWidget(self.tests_path, row, 1, 1, 1)
        btn_browse_tests = QPushButton("…")
        btn_browse_tests.clicked.connect(lambda: self._select(self.tests_path, "Word Documents (*.docx)", save=False))
        g.addWidget(btn_browse_tests, row, 2)
        row += 1

        btn_calc11 = QPushButton("Калькулятор Тест 11 (расход)…")
        btn_calc11.clicked.connect(self.launch_test11_calculator)
        g.addWidget(btn_calc11, row, 0, 1, 3)
        row += 1

        g.addWidget(QLabel("Excel с тестами:"), row, 0)
        self.xls_path = QLineEdit()
        self.xls_path.setReadOnly(True)
        g.addWidget(self.xls_path, row, 1, 1, 1)
        btn_browse_xls = QPushButton("…")
        btn_browse_xls.clicked.connect(lambda: self._select(self.xls_path, "Excel Files (*.xlsx)", save=False))
        g.addWidget(btn_browse_xls, row, 2)
        row += 1

        self.tests_btn = QPushButton("Выбрать тесты…")
        self.tests_btn.clicked.connect(self.choose_tests)
        g.addWidget(self.tests_btn, row, 0, 1, 3)
        row += 1

        g.addWidget(QLabel("Excel-оборудование:"), row, 0)
        self.equipment_xls_path = QLineEdit()
        self.equipment_xls_path.setReadOnly(True)
        g.addWidget(self.equipment_xls_path, row, 1, 1, 1)
        btn_eq = QPushButton("Загрузить оборудование")
        btn_eq.clicked.connect(lambda: self.load_equipment(silent=False))
        g.addWidget(btn_eq, row, 2)
        row += 1

        btn_rooms = QPushButton("Настройки помещений…")
        btn_rooms.clicked.connect(self.edit_rooms)
        g.addWidget(btn_rooms, row, 0, 1, 3)
        row += 1

        g.addWidget(QLabel("Папка со сканами (поверки):"), row, 0)
        self.scans_dir_input = QLineEdit()
        g.addWidget(self.scans_dir_input, row, 1, 1, 1)
        btn_dir = QPushButton("…")
        btn_dir.clicked.connect(lambda: self._select_dir(self.scans_dir_input))
        g.addWidget(btn_dir, row, 2)
        row += 1

        # Приложение 1
        g.addWidget(QLabel("Приложение 1:"), row, 0, Qt.AlignTop)
        self.app1_btn = QPushButton("Выбрать / перетащить файлы…")
        self.app1_btn.clicked.connect(self.choose_app1_images)
        g.addWidget(self.app1_btn, row, 1, 1, 2)
        row += 1

        self.app1_info = QLabel("Файлы не выбраны")
        self.app1_info.setWordWrap(True)
        g.addWidget(self.app1_info, row, 1, 1, 2)
        row += 1

        # Приложение 4
        g.addWidget(QLabel("Приложение 4:"), row, 0, Qt.AlignTop)
        self.app4_btn = QPushButton("Выбрать / перетащить файлы…")
        self.app4_btn.clicked.connect(self.choose_app4_images)
        g.addWidget(self.app4_btn, row, 1, 1, 2)
        row += 1

        self.app4_info = QLabel("Файлы не выбраны")
        self.app4_info.setWordWrap(True)
        g.addWidget(self.app4_info, row, 1, 1, 2)
        row += 1

        # Приложение 5
        g.addWidget(QLabel("Приложение 5:"), row, 0, Qt.AlignTop)
        self.app5_btn = QPushButton("Выбрать / перетащить файлы…")
        self.app5_btn.clicked.connect(self.choose_app5_images)
        g.addWidget(self.app5_btn, row, 1, 1, 2)
        row += 1

        self.app5_info = QLabel("Файлы не выбраны")
        self.app5_info.setWordWrap(True)
        g.addWidget(self.app5_info, row, 1, 1, 2)
        row += 1

        fields = [
            ("Объект:", "object_input"), ("ПРТ:", "prt_input"),
            ("Год:", "year_input"), ("Заказчик:", "customer_input"),
            ("Адрес объекта:", "address_input"),
            ("Разработал:", "developed_input"), ("Проверил:", "checked_input"),
        ]
        for label, attr in fields:
            g.addWidget(QLabel(label), row, 0)
            le = QLineEdit()
            setattr(self, attr, le)
            g.addWidget(le, row, 1, 1, 2)
            row += 1

        dates = [
            ("Дата разработки:", "date_dev"),
            ("Дата проверки:", "date_check"),
            ("Дата начала испытания:", "date_test"),
            ("Дата окончания:", "date_end"),
        ]
        for label, attr in dates:
            g.addWidget(QLabel(label), row, 0)
            de = QDateEdit(calendarPopup=True)
            de.setDate(date.today())
            setattr(self, attr, de)
            g.addWidget(de, row, 1, 1, 2)
            row += 1

        g.addWidget(QLabel("Сохранить как (.docx):"), row, 0)
        self.out_path = QLineEdit()
        g.addWidget(self.out_path, row, 1, 1, 1)
        btn_save = QPushButton("…")
        btn_save.clicked.connect(lambda: self._select(self.out_path, "Word Documents (*.docx)", save=True))
        g.addWidget(btn_save, row, 2)
        row += 1

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 20)
        g.addWidget(self.progress_bar, row, 0, 1, 3)
        row += 1

        btn_generate = QPushButton("Сгенерировать")
        btn_generate.clicked.connect(self.start_render)
        g.addWidget(btn_generate, row, 0, 1, 3)

        cw.setLayout(g)
        self.setCentralWidget(cw)

    def _select(self, widget: QLineEdit, flt: str, save: bool = False) -> None:
        if save:
            path, _ = QFileDialog.getSaveFileName(self, "Сохранить файл", os.getcwd(), flt)
        else:
            path, _ = QFileDialog.getOpenFileName(self, "Выберите файл", os.getcwd(), flt)
        if path:
            widget.setText(path)

    def _select_dir(self, widget: QLineEdit) -> None:
        d = QFileDialog.getExistingDirectory(self, "Выберите папку со сканами", os.getcwd())
        if d:
            widget.setText(d)

    def choose_app1_images(self):
        dlg = AppendixImagesDialog(
            self,
            title="Приложение 1 — загрузка изображений/скриншотов",
            initial_paths=self.app1_images,
            paste_prefix="app1"
        )
        if dlg.exec() == QDialog.Accepted:
            self.app1_images = dlg.get_paths()
            self.app1_info.setText(f"Выбрано файлов: {len(self.app1_images)}")

    def choose_app4_images(self):
        dlg = AppendixImagesDialog(
            self,
            title="Приложение 4 — загрузка изображений/скриншотов",
            initial_paths=self.app4_images,
            paste_prefix="app4"
        )
        if dlg.exec() == QDialog.Accepted:
            self.app4_images = dlg.get_paths()
            self.app4_info.setText(f"Выбрано файлов: {len(self.app4_images)}")

    def choose_app5_images(self):
        dlg = AppendixImagesDialog(
            self,
            title="Приложение 5 — загрузка изображений/скриншотов",
            initial_paths=self.app5_images,
            paste_prefix="app5"
        )
        if dlg.exec() == QDialog.Accepted:
            self.app5_images = dlg.get_paths()
            self.app5_info.setText(f"Выбрано файлов: {len(self.app5_images)}")

    def on_mode_changed(self, mode: str) -> None:
        if mode in ("OQ и PQ", "ОQ и PQ"):
            self.tpl_path.setText("")
            self.tests_path.setText("")
            self.xls_path.setText("")
            self.equipment_xls_path.setText("")
            self.scans_dir_input.setText("")
            return

        d = self.defaults[mode]
        self.tpl_path.setText(str(d["tpl"]))
        self.tests_path.setText(str(d["tests"]))
        self.xls_path.setText(str(d["xls_tests"]))
        self.equipment_xls_path.setText(str(d["xls_eq"]))
        self.scans_dir_input.setText(str(d["scans_dir"]))
        self.load_tests(silent=True)
        self.load_equipment(silent=True)

    def load_tests(self, silent: bool = False) -> None:
        try:
            path = Path(self.xls_path.text())
            self.all_tests = io_manager.load_tests_list(path)
            self.selected_tests = []
            if not silent:
                QMessageBox.information(self, "Тесты загружены", f"Всего тестов: {len(self.all_tests)}")
        except Exception as e:
            QMessageBox.critical(self, "Ошибка загрузки тестов", str(e))

    def choose_tests(self) -> None:
        if not self.all_tests:
            QMessageBox.warning(self, "Нет тестов", "Тесты не загружены!")
            return

        dlg = TestsDialog(self, self.all_tests, self.selected_tests,
                          calc_launcher=self.launch_test11_calculator)
        if dlg.exec() == QDialog.Accepted:
            self.selected_tests = dlg.get_selected()

    def load_equipment(self, silent: bool = False) -> None:
        try:
            path = Path(self.equipment_xls_path.text())
            by_sheets = io_manager.load_equipment_by_sheets(path)
            if silent:
                self.equipment = [it for items in by_sheets.values() for it in items]
                return
            dlg = EquipmentDialog(self, by_sheets)
            if dlg.exec() == QDialog.Accepted:
                self.equipment = dlg.get_selected()
        except Exception as e:
            QMessageBox.critical(self, "Ошибка загрузки оборудования", str(e))

    def edit_rooms(self) -> None:
        dlg = RoomsDialog(self, self.rooms)
        if dlg.exec() == QDialog.Accepted:
            self.rooms = dlg.get_rooms()

    def launch_test11_calculator(self, *_, auto_close: bool = True) -> int:
        import subprocess

        tpl_path_str = (self.tests_path.text().strip() or "")
        if not tpl_path_str:
            QMessageBox.critical(self, "Калькулятор Тест 11", "Не указан «Документ-тесты (.docx)».")
            return 1

        tpl_path = Path(tpl_path_str).expanduser().resolve()
        if not tpl_path.exists():
            QMessageBox.critical(self, "Калькулятор Тест 11", f"Файл не найден:\n{tpl_path}")
            return 1

        rooms: List[Dict[str, Any]] = list(self.rooms) if getattr(self, "rooms", None) else []
        n = max(1, len(rooms) or 1)

        def _get(room: Dict[str, Any], key: str, default: str) -> str:
            v = room.get(key)
            s = "" if v is None else str(v).strip()
            return s if s else default

        # забираем из "Настройки помещений": num, name, klass, area, airflow
        nums = [_get(r, "num", f"{i + 1}") for i, r in enumerate(rooms[:n])]
        names = [_get(r, "name", "") for r in rooms[:n]]
        klasses = [_get(r, "klass", "") for r in rooms[:n]]
        areas = [_get(r, "area", "1") for r in rooms[:n]]

        # этих полей в RoomsDialog нет -> остаются дефолты (если не добавлял их отдельно)
        filters = [_get(r, "filters", "2") for r in rooms[:n]]
        points = [_get(r, "points", "2") for r in rooms[:n]]

        airflows = [_get(r, "airflow", "") for r in rooms[:n]]

        def _pad(lst, filler):
            need = n - len(lst)
            return lst if need <= 0 else lst + [filler(len(lst) + k + 1) for k in range(need)]

        nums = _pad(nums, lambda k: str(k))
        names = _pad(names, lambda _: "")
        klasses = _pad(klasses, lambda _: "")
        areas = _pad(areas, lambda _: "1")
        filters = _pad(filters, lambda _: "2")
        points = _pad(points, lambda _: "2")
        airflows = _pad(airflows, lambda _: "")

        def _join(xs: List[str]) -> str:
            # безопасно для разделителя ;
            return ";".join(x.replace(";", " ").strip() for x in xs)

        nums_s = _join(nums)
        names_s = _join(names)
        klasses_s = _join(klasses)
        areas_s = _join(areas)
        filters_s = _join(filters)
        points_s = _join(points)
        airflows_s = _join(airflows)

        proj_root = Path(__file__).resolve().parents[1]
        candidates = [
            proj_root / "tools" / "test11_airflow_calc.py",
            Path.cwd() / "tools" / "test11_airflow_calc.py",
            proj_root / "tests" / "test11_airflow_calc.py",
            Path(__file__).resolve().parent / "test11_airflow_calc.py",
        ]
        script = next((p for p in candidates if p.exists()), None)
        if script is None:
            paths_list = "\n".join(str(p) for p in candidates)
            QMessageBox.critical(
                self, "Калькулятор Тест 11",
                "Не найден скрипт test11_airflow_calc.py по путям:\n\n" + paths_list
            )
            return 1

        tmp_dir = Path(tempfile.mkdtemp(prefix="test11_"))
        auto_save_path = tmp_dir / "test11_auto_save.docx"

        args: List[str] = [
            sys.executable, str(script),
            "--template", str(tpl_path),
            "--rooms", str(n),
            "--nums", nums_s,
            "--names", names_s,
            "--klasses", klasses_s,  # <-- ВАЖНО
            "--areas", areas_s,
            "--filters", filters_s,
            "--points", points_s,
            "--airflows", airflows_s,
            "--auto-save", str(auto_save_path),
        ]
        if auto_close:
            args.append("--auto-close")

        try:
            proc = subprocess.run(args, check=False)
            rc = int(proc.returncode or 0)
        except Exception as e:
            QMessageBox.critical(self, "Калькулятор Тест 11", f"Ошибка запуска:\n{e}")
            return 1

        if auto_save_path.exists():
            self.tests_path.setText(str(auto_save_path))

        setattr(self, "last_test11_autosave", str(auto_save_path))
        return rc

    def start_render(self) -> None:
        mode = self.mode_combo.currentText()
        if mode == "OQ и PQ":
            self._batch_modes = ["OQ", "PQ"]
            self._start_single_render(self._batch_modes.pop(0))
        else:
            self._batch_modes = []
            self._start_single_render(mode)

    def _start_single_render(self, mode: str) -> None:
        mode = mode.upper()
        use_ui_paths = (self.mode_combo.currentText().upper() == mode)

        if use_ui_paths:
            tpl_path = self.tpl_path.text().strip()
            tests_path = self.tests_path.text().strip()
            xls_tests = self.xls_path.text().strip()
            xls_eq = self.equipment_xls_path.text().strip()
            scans_dir = self.scans_dir_input.text().strip()
            sel_tests_raw = self.selected_tests[:]
            equipment_list = self.equipment[:]
            # risk берем из defaults (UI поля под него нет)
            risk_path = str(self.defaults[mode]["risk_doc"])
        else:
            d = self.defaults[mode]
            tpl_path = str(d["tpl"])
            tests_path = str(d["tests"])
            xls_tests = str(d["xls_tests"])
            xls_eq = str(d["xls_eq"])
            scans_dir = str(d["scans_dir"])
            risk_path = str(d["risk_doc"])
            try:
                sel_tests_raw = io_manager.load_tests_list(Path(xls_tests))
            except Exception as e:
                QMessageBox.critical(self, f"Ошибка загрузки тестов ({mode})", str(e))
                return
            try:
                by_sheets = io_manager.load_equipment_by_sheets(Path(xls_eq))
                equipment_list = [it for items in by_sheets.values() for it in items]
            except Exception as e:
                QMessageBox.critical(self, f"Ошибка загрузки оборудования ({mode})", str(e))
                return

        app1_images = self.app1_images[:]
        app4_images = self.app4_images[:]
        app5_images = self.app5_images[:]

        out_base = Path(self.out_path.text().strip())
        if not out_base.name:
            QMessageBox.critical(self, "Ошибка", "Не указан путь сохранения")
            return

        out_path = out_base.with_name(out_base.stem + f"_{mode}.docx")

        # ---------- ОТЧ (для текущего mode) ----------
        base = Path(__file__).resolve().parents[1]
        tpl_report_path = None
        out_report_path = None
        ctx_fields_report = None
        xls_report_path = None

        if mode in ("OQ", "PQ"):
            report_code = mode  # "OQ" или "PQ"

            candidate_tpl = base / f"Шаблон ОТЧ-{report_code}.docx"
            if candidate_tpl.exists():
                tpl_report_path = str(candidate_tpl)
                out_report_path = str(out_base.with_name(out_base.stem + f"_{mode}_ОТЧ-{report_code}.docx"))
            else:
                logger.warning(f"Шаблон отчёта ОТЧ-{report_code} не найден: {candidate_tpl}")

            candidate_xls = base / f"ОТЧ-{report_code}.xlsx"
            if candidate_xls.exists():
                xls_report_path = str(candidate_xls)
            else:
                logger.warning(f"Excel отчёта ОТЧ-{report_code} не найден: {candidate_xls}")

        missing_fields = []
        if not tpl_path:
            missing_fields.append("шаблон")
        if not tests_path:
            missing_fields.append("документ-тесты")
        if not xls_tests:
            missing_fields.append("Excel с тестами")
        if not xls_eq:
            missing_fields.append("Excel оборудование")
        if missing_fields:
            QMessageBox.critical(self, f"Ошибка ({mode})", "Не указаны: " + ", ".join(missing_fields))
            return

        sel_tests = [
            re.sub(r"(?i)^тест\s*\d+(?:\.\d+)?\.?\s*", "", s).strip()
            for s in sel_tests_raw if isinstance(s, str) and s.strip()
        ]

        def _norm_doc_id(raw: str) -> str:
            s = (raw or "").strip().upper()
            # если пользователь вставил уже с префиксом — срежем
            prefixes = (
                "ПРТ-OQ-", "ПРТ-PQ-", "ПРТ-IQ-",
                "ОТЧ-OQ-", "ОТЧ-PQ-", "ОТЧ-IQ-",
                "ПРТ-", "ОТЧ-",
            )
            for p in prefixes:
                if s.startswith(p):
                    s = s[len(p):]
                    break
            return s

        doc_id = _norm_doc_id(self.prt_input.text())

        # основной документ (OQ/PQ): {{prt}} = ПРТ-<ввод>
        prt = RichText(
            f"ПРТ-{doc_id}" if doc_id else "",
            bold=False, italic=False, underline=False
        )

        # отчёт ОТЧ-(OQ/PQ): {{prt}} = ОТЧ-<mode>-<ввод>
        prt_report = RichText(
            f"ОТЧ-{mode}-{doc_id}" if doc_id else "",
            bold=False, italic=False, underline=False
        )

        # отчёт: {{prt1}} = ПРТ-<mode>-<ввод>
        prt1_report = RichText(
            f"ПРТ-{mode}-{doc_id}" if doc_id else "",
            bold=False, italic=False, underline=False
        )

        object_text = self.object_input.text().strip()
        object_rd = ""
        if object_text:
            morph = MorphAnalyzer()
            words = object_text.split()
            parsed = [morph.parse(w)[0] for w in words]
            adj_idx = next((i for i, p in enumerate(parsed[:-1]) if "ADJF" in p.tag), None)
            noun_idx = adj_idx + 1 if adj_idx is not None and adj_idx + 1 < len(parsed) else None
            if adj_idx is not None and noun_idx is not None and "NOUN" in parsed[noun_idx].tag:
                adj = parsed[adj_idx]
                noun = parsed[noun_idx]
                gender = noun.tag.gender
                number = noun.tag.number
                adj_gent = adj.inflect({"gent", gender, number})
                noun_gent = noun.inflect({"gent"})
                if adj_gent and noun_gent:
                    before = " ".join(words[:adj_idx])
                    after = " ".join(words[noun_idx + 1:])
                    object_rd = f"{before} {adj_gent.word} {noun_gent.word} {after}".strip()
                else:
                    object_rd = object_text
            else:
                first_noun = next((p for p in parsed if "NOUN" in p.tag), None)
                if first_noun:
                    infl = first_noun.inflect({"gent"})
                    if infl:
                        idx = parsed.index(first_noun)
                        object_rd = " ".join(words[:idx] + [infl.word] + words[idx + 1:])
                    else:
                        object_rd = object_text
                else:
                    object_rd = object_text

        ctx_fields: Dict[str, Any] = {
            "объект": object_text,
            "объект1": object_rd,
            "prt": prt,
            "year": self.year_input.text().strip(),
            "customer": self.customer_input.text().strip(),
            "address": self.address_input.text().strip(),
            "Разработал": self.developed_input.text().strip(),
            "Проверил": self.checked_input.text().strip(),
            "Дата_Разработки": self.date_dev.date().toString("dd.MM.yyyy"),
            "Дата_Проверки": self.date_check.date().toString("dd.MM.yyyy"),
            "ДАТА_начала_испытания": self.date_test.date().toString("dd.MM.yyyy"),
            "ДАТА_окончания": self.date_end.date().toString("dd.MM.yyyy"),
            "Тесты_маркированным_списком": RichText("\n".join(f"• {t}" for t in sel_tests), bold=False),
        }

        # контекст для отчёта (только если реально есть шаблон и путь)
        if mode in ("OQ", "PQ") and tpl_report_path and out_report_path:
            ctx_fields_report = dict(ctx_fields)
            ctx_fields_report["prt"] = prt_report
            ctx_fields_report["prt1"] = prt1_report

        self.setEnabled(False)
        self.progress_bar.setValue(0)

        self.worker = RenderWorker(
            tpl_path, tests_path, xls_tests, xls_eq, str(out_path),
            sel_tests, self.rooms, equipment_list, ctx_fields,
            risk_path=risk_path,
            scans_dir=scans_dir,
            app1_images=app1_images,
            app4_images=app4_images,
            app5_images=app5_images,

            # ОТЧ (для текущего mode)
            tpl_report_path=tpl_report_path,
            out_report_path=out_report_path,
            ctx_fields_report=ctx_fields_report,
            xls_report_path=xls_report_path,
            report_code=mode,
        )

        self.worker.progress.connect(self.on_progress)
        self.worker.finished.connect(self.on_finished)
        self.worker.start()

    def on_progress(self, step: int, message: str) -> None:
        self.progress_bar.setValue(step)
        self.statusBar().showMessage(message)

    def on_finished(self, success: bool, message: str, missing: list[str]) -> None:
        if self._batch_modes:
            next_mode = self._batch_modes.pop(0)
            if success:
                if missing:
                    QMessageBox.warning(self, "Внимание", "Не вставлены тесты:\n" + "\n".join(missing))
                logger.info(message)
            else:
                QMessageBox.critical(self, "Ошибка", message)
                self._batch_modes.clear()
                self.setEnabled(True)
                self.statusBar().clearMessage()
                return
            self._start_single_render(next_mode)
            return

        self.setEnabled(True)
        if success:
            if missing:
                QMessageBox.warning(self, "Внимание", "Не вставлены тесты:\n" + "\n".join(missing))
            QMessageBox.information(self, "Успех", message)
        else:
            QMessageBox.critical(self, "Ошибка", message)
        self.statusBar().clearMessage()


def main():
    app = QApplication(sys.argv)
    wnd = MainWindow()
    wnd.resize(900, 760)
    wnd.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()



from PySide6.QtWidgets import QMainWindow, QLabel
from PySide6.QtCore import Qt

class OldCleanroomWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Старый режим — Чистые помещения")
        label = QLabel("Режим чистых помещений пока реализован в старом виде.")
        label.setAlignment(Qt.AlignCenter)
        self.setCentralWidget(label)


def launch_old_app():
    return OldCleanroomWindow()


# ui/rooms_table.py  (новый файл)
from PySide6.QtWidgets import QTableWidget, QTableWidgetItem, QApplication
from PySide6.QtCore import Qt

class SpreadsheetTable(QTableWidget):
    """
    QTableWidget с excel-копипастой:
      • Ctrl+C — копирует текущее выделение как TSV
      • Ctrl+V — вставляет прямоугольный блок (TSV/CSV/строки)
      • если нет выделения — работаем от (0,0)
      • автоматически добавляет недостающие строки
    """
    def keyPressEvent(self, e):
        ctrl = e.modifiers() & Qt.ControlModifier
        if ctrl and e.key() == Qt.Key_C:
            self._copy_selection_to_clipboard()
            return
        if ctrl and e.key() == Qt.Key_V:
            self._paste_from_clipboard()
            return
        super().keyPressEvent(e)

    # --- helpers ---
    def _copy_selection_to_clipboard(self):
        rngs = self.selectedRanges()
        if rngs:
            r = rngs[0]
            rows = range(r.topRow(), r.bottomRow() + 1)
            cols = range(r.leftColumn(), r.rightColumn() + 1)
        else:
            # нет выделения — копируем всё содержимое
            rows = range(0, self.rowCount())
            cols = range(0, self.columnCount())

        lines = []
        for i in rows:
            vals = []
            for j in cols:
                it = self.item(i, j)
                vals.append("" if it is None else it.text())
            lines.append("\t".join(vals))
        QApplication.clipboard().setText("\n".join(lines))

    def _paste_from_clipboard(self):
        text = QApplication.clipboard().text()
        if not text:
            return

        # поддержка TSV/CSV
        rows_data = [
            [c.strip() for c in row.replace(";", "\t").split("\t")]
            for row in text.splitlines()
            if row.strip() != ""
        ]
        if not rows_data:
            return

        # точка вставки — левый верх выделения, иначе (0,0)
        rngs = self.selectedRanges()
        start_row = rngs[0].topRow() if rngs else 0
        start_col = rngs[0].leftColumn() if rngs else 0

        needed_rows = start_row + len(rows_data)
        if self.rowCount() < needed_rows:
            self.setRowCount(needed_rows)

        needed_cols = start_col + max(len(r) for r in rows_data)
        if self.columnCount() < needed_cols:
            self.setColumnCount(needed_cols)

        for i, row_vals in enumerate(rows_data):
            for j, val in enumerate(row_vals):
                r = start_row + i
                c = start_col + j
                it = self.item(r, c)
                if it is None:
                    it = QTableWidgetItem()
                    self.setItem(r, c, it)
                it.setText(val)


# ui/startup_dialog.py
from PySide6.QtWidgets import QDialog, QVBoxLayout, QPushButton

class StartupDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Выберите режим работы")
        self.resize(300, 150)
        self.choice = None

        layout = QVBoxLayout(self)

        btn_eq = QPushButton("Оборудование")
        btn_cr = QPushButton("Чистые помещения")

        btn_eq.clicked.connect(lambda: self._select("equipment"))
        btn_cr.clicked.connect(lambda: self._select("cleanrooms"))

        layout.addWidget(btn_eq)
        layout.addWidget(btn_cr)

    def _select(self, choice):
        self.choice = choice
        self.accept()

    def get_choice(self):
        return self.choice



from PySide6.QtWidgets import QApplication

def apply_compact_style(app: QApplication) -> None:
    app.setStyle("Fusion")
    app.setStyleSheet("""
        QWidget { font-size: 10pt; }
        QLineEdit, QComboBox, QDateEdit {
            padding: 5px 8px;
            border-radius: 6px;
        }
        QPushButton {
            padding: 6px 10px;
            border-radius: 6px;
        }
        QToolButton {
            padding: 4px 6px;
            border-radius: 6px;
        }
        QGroupBox {
            margin-top: 10px;
            font-weight: 600;
        }
        QGroupBox::title {
            subcontrol-origin: margin;
            left: 10px;
            padding: 0 4px;
        }
    """)



# ui/widgets.py
from __future__ import annotations

import os
from pathlib import Path

from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import QWidget, QHBoxLayout, QLineEdit, QToolButton, QFileDialog


class PathEdit(QWidget):
    textChanged = Signal(str)

    def __init__(self, parent=None, *, file_filter: str = "All files (*.*)", kind: str = "open"):
        super().__init__(parent)
        self._filter = file_filter
        self._kind = kind  # "open" | "save" | "dir"

        self._edit = QLineEdit(self)
        self._btn = QToolButton(self)
        self._btn.setText("…")
        self._btn.setCursor(Qt.PointingHandCursor)

        lay = QHBoxLayout(self)
        lay.setContentsMargins(0, 0, 0, 0)
        lay.setSpacing(6)
        lay.addWidget(self._edit, 1)
        lay.addWidget(self._btn)

        self._edit.textChanged.connect(self.textChanged)
        self._btn.clicked.connect(self._browse)

    # --- QLineEdit-like API (важно для совместимости) ---
    def text(self) -> str:
        return self._edit.text()

    def setText(self, s: str) -> None:
        self._edit.setText(s)

    def setReadOnly(self, ro: bool) -> None:
        self._edit.setReadOnly(ro)

    def clear(self) -> None:
        self._edit.clear()

    def _browse(self) -> None:
        start_dir = os.path.dirname(self.text()) if self.text() else os.getcwd()

        if self._kind == "dir":
            p = QFileDialog.getExistingDirectory(self, "Выберите папку", start_dir)
            if p:
                self.setText(str(Path(p).resolve()))
            return

        if self._kind == "save":
            p, _ = QFileDialog.getSaveFileName(self, "Сохранить файл", start_dir, self._filter)
        else:
            p, _ = QFileDialog.getOpenFileName(self, "Выберите файл", start_dir, self._filter)

        if p:
            self.setText(str(Path(p).resolve()))





from __future__ import annotations

import re
from typing import Optional

import win32com.client as win32
from win32com.client import constants as c


def _clean_cell_text(s: str) -> str:
    # Word возвращает текст ячейки с '\r\x07'
    s = (s or "").replace("\r", "").replace("\x07", "")
    s = s.replace("\u00A0", " ")
    s = re.sub(r"\s+", " ", s).strip()
    return s


def _norm(s: str) -> str:
    return _clean_cell_text(s).lower().replace("ё", "е")


def _looks_like_table2(word_table) -> bool:
    """
    Узнаём Таблицу 2 по шапке:
    'Тест', 'Критерий приемлемости', 'Фактические результаты', 'Оценка'
    """
    try:
        if word_table.Rows.Count < 1:
            return False
        row1 = word_table.Rows(1)
        head = " ".join(_clean_cell_text(cell.Range.Text) for cell in row1.Cells)
        h = _norm(head)
        return ("тест" in h and "критер" in h and "фактичес" in h and "оценк" in h)
    except Exception:
        return False


def _insert_continuation_block_before_table(word_app, doc, table, title: str) -> None:
    """
    Вставляет ПЕРЕД table:
      - абзац 'Продолжение таблицы 2' (TNR12 bold, справа)
      - абзац начинается С НОВОЙ СТРАНИЦЫ (PageBreakBefore=True)
    ВАЖНО: гарантированно вставляем ВНЕ таблицы (не в ячейку).
    """
    sel = word_app.Selection

    # Ставим курсор в начало новой таблицы
    sel.SetRange(table.Range.Start, table.Range.Start)

    # Гарантированно выходим из таблицы в "параграф-якорь" перед ней
    # Иногда Word держит Range внутри первой ячейки — выходим MoveLeft'ом.
    guard = 0
    while sel.Information(c.wdWithInTable) and guard < 50:
        sel.MoveLeft(Unit=c.wdCharacter, Count=1)
        guard += 1

    # Теперь мы вне таблицы: вставляем абзац перед таблицей
    sel.InsertParagraphAfter()          # создаём параграф перед таблицей
    sel.MoveUp(Unit=c.wdParagraph, Count=1)

    # Настраиваем абзац как "начало новой страницы"
    sel.ParagraphFormat.PageBreakBefore = True
    sel.ParagraphFormat.Alignment = c.wdAlignParagraphRight
    sel.ParagraphFormat.SpaceBefore = 0
    sel.ParagraphFormat.SpaceAfter = 0

    # Текст + шрифт
    sel.Font.Name = "Times New Roman"
    sel.Font.Size = 12
    sel.Font.Bold = True
    sel.TypeText(title)

    # Важно: НЕ InsertBreak() — иначе может появляться пустая страница
    # И НЕ InsertParagraphAfter() — иначе появится лишняя пустая строка


def split_table2_with_continuation_word(
    docx_path: str,
    *,
    continuation_title: str = "Продолжение таблицы 2",
    header_rows_count: int = 1,
    max_splits: int = 20,
) -> bool:
    """
    Режет Таблицу 2 по фактическому переносу на следующую страницу (через Word пагинацию).
    Возвращает True если хотя бы один разрез сделан.
    """
    word = win32.gencache.EnsureDispatch("Word.Application")
    word.Visible = False

    did_any = False
    try:
        doc = word.Documents.Open(str(docx_path))

        # если уже есть "Продолжение таблицы 2" — не плодим дубли
        if continuation_title in _clean_cell_text(doc.Content.Text):
            doc.Close(SaveChanges=False)
            return False

        doc.Repaginate()

        # найдём таблицу 2
        t2 = None
        for t in doc.Tables:
            if _looks_like_table2(t):
                t2 = t
                break

        if t2 is None:
            doc.Close(SaveChanges=False)
            return False

        # сделаем шапку повторяемой
        try:
            for i in range(1, header_rows_count + 1):
                t2.Rows(i).HeadingFormat = True
        except Exception:
            pass

        splits_done = 0
        cur_table = t2

        while splits_done < max_splits:
            doc.Repaginate()

            # страница, на которой заканчивается шапка
            base_page = cur_table.Rows(header_rows_count).Range.Information(c.wdActiveEndPageNumber)

            # найдём первую строку данных, которая ушла на следующую страницу
            split_row_idx: Optional[int] = None
            for ri in range(header_rows_count + 1, cur_table.Rows.Count + 1):
                pg = cur_table.Rows(ri).Range.Information(c.wdActiveEndPageNumber)
                if pg > base_page:
                    split_row_idx = ri
                    break

            if split_row_idx is None:
                break  # таблица целиком помещается на странице

            # 1) Копируем текущую таблицу после неё же
            count_before = doc.Tables.Count
            ins = cur_table.Range
            ins.Collapse(c.wdCollapseEnd)
            ins.InsertParagraphAfter()
            ins.Collapse(c.wdCollapseEnd)

            cur_table.Range.Copy()
            ins.PasteAndFormat(c.wdFormatOriginalFormatting)

            new_table = doc.Tables(count_before + 1)

            # 2) В НОВОЙ таблице удаляем строки ДО split_row_idx (кроме шапки)
            for _ in range((split_row_idx - 1) - header_rows_count):
                new_table.Rows(header_rows_count + 1).Delete()

            # 3) В СТАРОЙ таблице удаляем строки split_row_idx..конец
            while cur_table.Rows.Count >= split_row_idx:
                cur_table.Rows(split_row_idx).Delete()

            # 4) Вставляем "Продолжение таблицы 2" ПЕРЕД новой таблицей (вне таблицы!)
            _insert_continuation_block_before_table(word, doc, new_table, continuation_title)

            # 5) Повторяемая шапка для новой таблицы
            try:
                for i in range(1, header_rows_count + 1):
                    new_table.Rows(i).HeadingFormat = True
            except Exception:
                pass

            did_any = True
            splits_done += 1
            cur_table = new_table

        doc.Save()
        doc.Close()
        return did_any

    finally:
        word.Quit()


def update_fields_and_split_table2(
    docx_path: str,
    *,
    continuation_title: str = "Продолжение таблицы 2",
    header_rows_count: int = 1,
) -> bool:
    """
    1) Режет Таблицу 2 по фактическому переносу страницы (через Word).
    2) Обновляет поля документа + колонтитулы.
    Возвращает True если были сделаны разрезы.
    """
    did_split = split_table2_with_continuation_word(
        docx_path,
        continuation_title=continuation_title,
        header_rows_count=header_rows_count,
    )

    # Обновление полей/колонтитулов отдельным проходом (надежно)
    word = win32.gencache.EnsureDispatch("Word.Application")
    word.Visible = False
    try:
        doc = word.Documents.Open(str(docx_path))
        doc.Repaginate()

        doc.Fields.Update()
        for sec in doc.Sections:
            try:
                sec.Headers(1).Range.Fields.Update()
            except Exception:
                pass
            try:
                sec.Footers(1).Range.Fields.Update()
            except Exception:
                pass

        doc.Save()
        doc.Close()
    finally:
        word.Quit()

    return did_split




# file_utils.py
from tempfile import NamedTemporaryFile
from contextlib import contextmanager

@contextmanager
def temp_docx(suffix: str = ".docx"):
    f = NamedTemporaryFile(suffix=suffix, delete=False)
    try:
        yield f.name
    finally:
        try:
            f.close()
            import os
            os.remove(f.name)
        except OSError:
            pass



# io_manager.py
from __future__ import annotations

from pathlib import Path
from typing import List, Dict

import pandas as pd
from logger import logger


# ---------------------------
# Общие утилиты
# ---------------------------

def validate_file(path: Path) -> None:
    """Проверка существования файла на диске."""
    if not path.exists():
        logger.error(f"Файл не найден: {path}")
        raise FileNotFoundError(f"Файл не найден: {path}")


# ---------------------------
# Тесты (Excel -> список строк)
# ---------------------------

def load_tests_list(excel_path: Path) -> List[str]:
    """
    Читает Excel с тестами и возвращает список названий тестов.
    Берётся первый столбец первого листа (как было ранее).
    """
    validate_file(excel_path)
    df = pd.read_excel(excel_path, dtype=str)

    if df.empty or df.columns.size == 0:
        raise ValueError(f"В файле {excel_path} нет данных для тестов")

    tests = (
        df.iloc[:, 0]
        .dropna()
        .astype(str)
        .map(str.strip)
        .tolist()
    )
    logger.debug(f"Загружено тестов: {len(tests)} из {excel_path.name}")
    return tests


# ---------------------------
# Оборудование (Excel -> списки словарей)
# ---------------------------

def _parse_equipment_df(df: pd.DataFrame) -> List[dict]:
    """
    Универсальный парсер листа Excel с оборудованием.
    Возвращает список словарей с ключами: name_sn, params, cert, date, until
    """
    df = df.copy()
    df.rename(columns=lambda c: str(c).strip(), inplace=True)

    name_col  = next((c for c in df.columns if "Наименование" in c), None)
    sn_col    = next((c for c in df.columns if "зав" in str(c).lower()), None)
    param_col = next((c for c in df.columns if "Определяемые показатели" in c), None)
    cert_col  = next((c for c in df.columns if "№ свидетельств" in c or "№ свидетельтва" in c), None)
    date_col  = next((c for c in df.columns if "Дата поверки" in c), None)
    until_col = next((c for c in df.columns if "Срок действия поверки" in c), None)

    if not name_col or not sn_col:
        raise ValueError("Нет колонок «Наименование»/«Зав. (серийный) номер»")

    items: List[dict] = []
    for _, row in df.iterrows():
        nm = str(row[name_col]).strip() if pd.notna(row[name_col]) else ""
        if not nm:
            continue
        sn = str(row[sn_col]).strip() if pd.notna(row[sn_col]) else ""
        items.append({
            "name_sn": f"{nm}, {sn}".strip(", "),
            "params": str(row[param_col]).strip() if param_col and pd.notna(row.get(param_col)) else "",
            "cert":   str(row[cert_col]).strip()  if cert_col  and pd.notna(row.get(cert_col))  else "",
            "date":   str(row[date_col]).strip()  if date_col  and pd.notna(row.get(date_col))  else "",
            "until":  str(row[until_col]).strip() if until_col and pd.notna(row.get(until_col)) else "",
        })
    return items


def load_equipment_by_sheets(excel_path: Path) -> Dict[str, List[dict]]:
    """
    Возвращает {имя_листа: [элементы...]}. Все листы обрабатываются одинаково.
    Листы с ошибками парсинга не валят процесс — для них будет [] и warning в лог.
    """
    validate_file(excel_path)
    xls = pd.ExcelFile(excel_path)
    if not xls.sheet_names:
        raise ValueError(f"В файле {excel_path} нет листов Excel")

    result: Dict[str, List[dict]] = {}
    for sheet in xls.sheet_names:
        try:
            df = pd.read_excel(xls, sheet_name=sheet, dtype=str)
            result[sheet] = _parse_equipment_df(df)
            logger.debug(f"[{sheet}] загружено {len(result[sheet])} позиций")
        except Exception as e:
            logger.warning(f"Лист «{sheet}» пропущен: {e}")
            result[sheet] = []
    return result


def load_equipment_list(excel_path: Path) -> List[dict]:
    """
    Обратная совместимость: берёт первый лист (как в старой версии).
    """
    validate_file(excel_path)
    df = pd.read_excel(excel_path, dtype=str)
    return _parse_equipment_df(df)



# logger.py
import logging

logger = logging.getLogger("OQGen")
logger.setLevel(logging.DEBUG)

# файл
fh = logging.FileHandler("oq_generator.log", encoding="utf-8")
fmt = logging.Formatter("%(asctime)s %(levelname)s: %(message)s")
fh.setFormatter(fmt)
logger.addHandler(fh)

# консоль (по желанию)
ch = logging.StreamHandler()
ch.setFormatter(fmt)
logger.addHandler(ch)


# main.py
import sys
from PySide6.QtWidgets import QApplication
from ui.main_window import MainWindow

def main():
    app = QApplication(sys.argv)
    wnd = MainWindow()
    wnd.resize(800, 700)
    wnd.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()




from __future__ import annotations

import sys
import os
import re
import tempfile
import uuid
from pathlib import Path
from typing import List, Dict, Any
from datetime import datetime, date, timedelta
from decimal import Decimal, InvalidOperation

from PySide6.QtCore import Qt, QThread, Signal
from PySide6.QtGui import QDragEnterEvent, QDropEvent, QGuiApplication, QKeySequence, QShortcut
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QLineEdit, QListWidget,
    QListWidgetItem, QPushButton, QMessageBox, QFileDialog,
    QGridLayout, QDateEdit, QDialog, QVBoxLayout, QHBoxLayout,
    QSpinBox, QTableWidget, QTableWidgetItem, QProgressBar, QComboBox,
    QTabWidget, QAbstractItemView
)

from docx import Document
from docx.shared import Mm
from docx.image.exceptions import UnrecognizedImageError
from docxtpl import DocxTemplate, RichText, InlineImage
from pymorphy3 import MorphAnalyzer

from file_utils import temp_docx
import io_manager
import template_renderer
import table_processor
from logger import logger
import word_table5_splitter


# ===================== Spreadsheet-like table =====================
class SpreadsheetTable(QTableWidget):
    """QTableWidget с excel-копипастой."""
    def keyPressEvent(self, e):
        ctrl = bool(e.modifiers() & Qt.ControlModifier)
        if ctrl and e.key() == Qt.Key_C:
            self._copy_selection_to_clipboard()
            return
        if ctrl and e.key() == Qt.Key_V:
            self._paste_from_clipboard()
            return
        super().keyPressEvent(e)

    def _copy_selection_to_clipboard(self):
        rngs = self.selectedRanges()
        if rngs:
            r = rngs[0]
            rows = range(r.topRow(), r.bottomRow() + 1)
            cols = range(r.leftColumn(), r.rightColumn() + 1)
        else:
            rows = range(0, self.rowCount())
            cols = range(0, self.columnCount())

        lines = []
        for i in rows:
            vals = []
            for j in cols:
                it = self.item(i, j)
                vals.append("" if it is None else it.text())
            lines.append("\t".join(vals))
        QApplication.clipboard().setText("\n".join(lines))

    def _paste_from_clipboard(self):
        text = QApplication.clipboard().text()
        if not text:
            return
        rows_data = [
            [c.strip() for c in row.replace(";", "\t").split("\t")]
            for row in text.splitlines()
            if row.strip() != ""
        ]
        if not rows_data:
            return
        rngs = self.selectedRanges()
        start_row = rngs[0].topRow() if rngs else 0
        start_col = rngs[0].leftColumn() if rngs else 0
        need_r = start_row + len(rows_data)
        need_c = start_col + max(len(r) for r in rows_data)
        if self.rowCount() < need_r:
            self.setRowCount(need_r)
        if self.columnCount() < need_c:
            self.setColumnCount(need_c)
        for i, row_vals in enumerate(rows_data):
            for j, val in enumerate(row_vals):
                r = start_row + i
                c = start_col + j
                it = self.item(r, c)
                if it is None:
                    it = QTableWidgetItem()
                    self.setItem(r, c, it)
                it.setText(val)


# ===================== Rooms dialog =====================
class RoomsDialog(QDialog):
    def __init__(self, parent=None, initial_rooms: List[Dict[str, str]] | None = None):
        super().__init__(parent)
        self.setWindowTitle("Настройки помещений")
        self.resize(700, 450)

        self.spin = QSpinBox()
        self.spin.setRange(0, 100)
        self.spin.setValue(len(initial_rooms or []))
        self.spin.valueChanged.connect(self._on_count)

        self.tbl = SpreadsheetTable()
        self.tbl.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.tbl.setSelectionBehavior(QAbstractItemView.SelectItems)
        self.tbl.setEditTriggers(QAbstractItemView.AllEditTriggers)

        headers = [
            "Номер помещения", "Наименование", "Класс чистоты",
            "Площадь, м²", "Объём, м³", "Δдавл., Pa",
            "Расход, м³/ч", "Кратность, не менее", "Темп., °C", "RH, %"
        ]
        self.tbl.setColumnCount(len(headers))
        self.tbl.setHorizontalHeaderLabels(headers)

        self._on_count(self.spin.value())
        if initial_rooms:
            for r, data in enumerate(initial_rooms):
                for c, key in enumerate(
                    ["num", "name", "klass", "area", "volume",
                     "dp", "airflow", "exchange", "temp", "rh"]
                ):
                    self.tbl.setItem(r, c, QTableWidgetItem(data.get(key, "")))

        btn_ok = QPushButton("ОК")
        btn_cancel = QPushButton("Отмена")
        btn_ok.clicked.connect(self.accept)
        btn_cancel.clicked.connect(self.reject)

        hb = QHBoxLayout()
        hb.addStretch()
        hb.addWidget(btn_ok)
        hb.addWidget(btn_cancel)

        lay = QVBoxLayout(self)
        lay.addWidget(QLabel("Количество помещений:"))
        lay.addWidget(self.spin)
        lay.addWidget(self.tbl)
        lay.addLayout(hb)

    def _on_count(self, n: int) -> None:
        self.tbl.setRowCount(n)
        for r in range(n):
            for c in range(self.tbl.columnCount()):
                if not self.tbl.item(r, c):
                    self.tbl.setItem(r, c, QTableWidgetItem(""))

    def get_rooms(self) -> List[Dict[str, str]]:
        keys = ["num", "name", "klass", "area", "volume",
                "dp", "airflow", "exchange", "temp", "rh"]
        out: List[Dict[str, str]] = []
        for r in range(self.tbl.rowCount()):
            row: Dict[str, str] = {}
            for c, k in enumerate(keys):
                it = self.tbl.item(r, c)
                row[k] = (it.text().strip() if it else "")
            out.append(row)
        return out


# ===================== Equipment date helpers =====================
def _parse_any_date(v):
    """Пытается распарсить дату из datetime/date/строки/Excel-числа."""
    if v is None:
        return None

    if isinstance(v, datetime):
        return v.date()
    if isinstance(v, date):
        return v

    if isinstance(v, (int, float)):
        if v > 20000:
            base = datetime(1899, 12, 30)  # excel epoch
            return (base + timedelta(days=float(v))).date()
        return None

    s = str(v).strip()
    if not s:
        return None

    s2 = s.replace("T", " ").replace("Z", "").strip()

    try:
        dt = datetime.fromisoformat(s2)
        return dt.date()
    except Exception:
        pass

    m = re.match(r"^\s*(\d{4})[-/](\d{1,2})[-/](\d{1,2})", s2)
    if m:
        y, mo, d = map(int, m.groups())
        try:
            return date(y, mo, d)
        except Exception:
            return None

    m = re.match(r"^\s*(\d{1,2})[.\/](\d{1,2})[.\/](\d{4})", s2)
    if m:
        d, mo, y = map(int, m.groups())
        try:
            return date(y, mo, d)
        except Exception:
            return None

    return None


def _fmt_ddmmyyyy(v) -> str:
    d = _parse_any_date(v)
    return d.strftime("%d.%m.%Y") if d else ""


def _extract_two_dates_from_value(v) -> tuple[date | None, date | None]:
    """Если значение содержит 1 или 2 даты — вернём (d1, d2)."""
    if v is None:
        return (None, None)

    if isinstance(v, (datetime, date)):
        d = _parse_any_date(v)
        return (d, None)

    s = str(v).strip().replace("\u00a0", " ")
    if not s:
        return (None, None)

    s = re.sub(r"\s+", " ", s)
    cand = re.findall(
        r"\d{4}[-/]\d{1,2}[-/]\d{1,2}|\d{1,2}[./]\d{1,2}[./]\d{4}",
        s
    )
    dates_found: list[date] = []
    for c in cand:
        d = _parse_any_date(c)
        if d:
            dates_found.append(d)

    if not dates_found:
        d = _parse_any_date(s)
        return (d, None)

    if len(dates_found) == 1:
        return (dates_found[0], None)
    return (dates_found[0], dates_found[1])


# ===================== Equipment dialog =====================
class EquipmentDialog(QDialog):
    def __init__(self, parent=None, items_by_sheet: dict[str, list[dict]] | None = None):
        super().__init__(parent)
        self.setWindowTitle("Выбор оборудования")
        self.resize(900, 520)

        self.tabs = QTabWidget(self)
        self._lists: dict[str, QListWidget] = {}

        KEY_DATE_FROM = (
            "date_check", "check_date", "calibration_date", "date_from",
            "Дата поверки", "дата поверки", "дата_поверки",
        )
        KEY_DATE_TO = (
            "valid_to", "valid_until", "date_to", "expiry", "validity_to",
            "Действительно до", "действительно до",
            "Срок действия поверки", "срок действия поверки", "срок_действия_поверки",
        )
        KEY_DATE_RANGE = (
            "Дата поверки/ Действительно до:",
            "Дата поверки/Действительно до:",
            "Дата поверки / Действительно до:",
            "дата поверки/ действительно до",
            "дата поверки / действительно до",
            "дата поверки/действительно до",
        )

        def norm_key(s: str) -> str:
            return re.sub(r"\s+", " ", str(s or "")).strip().lower()

        def get_any(it: dict, keys: tuple[str, ...]):
            for k in keys:
                if k in it and it.get(k) not in (None, ""):
                    return it.get(k)

            nk = {norm_key(k): k for k in it.keys()}
            for k in keys:
                kk = nk.get(norm_key(k))
                if kk is not None and it.get(kk) not in (None, ""):
                    return it.get(kk)

            return None

        def find_range_value(it: dict):
            v = get_any(it, KEY_DATE_RANGE)
            if v not in (None, ""):
                return v

            for real_k, vv in it.items():
                if vv in (None, ""):
                    continue
                kk = norm_key(real_k)
                if ("поверк" in kk) and (("действ" in kk) or ("срок" in kk) or ("valid" in kk)):
                    return vv
            return None

        for sheet, items in (items_by_sheet or {}).items():
            lw = QListWidget()
            lw.setSelectionMode(QListWidget.MultiSelection)

            for it in items:
                name_sn = (it.get("name_sn") or it.get("name") or "").strip()

                raw_from = get_any(it, KEY_DATE_FROM)
                raw_to = get_any(it, KEY_DATE_TO)

                if (raw_from in (None, "")) and (raw_to in (None, "")):
                    rng = find_range_value(it)
                    d1, d2 = _extract_two_dates_from_value(rng)
                    if d1:
                        raw_from = d1
                    if d2:
                        raw_to = d2

                date_from = _fmt_ddmmyyyy(raw_from)
                date_to = _fmt_ddmmyyyy(raw_to)

                if date_to:
                    text = f"до {date_to} — {name_sn}"
                elif date_from:
                    text = f"поверка {date_from} — {name_sn}"
                else:
                    text = name_sn

                item = QListWidgetItem(text)
                item.setData(Qt.UserRole, it)
                item.setToolTip(
                    f"Поверка: {date_from or '—'}\n"
                    f"Действительно до: {date_to or '—'}"
                )
                lw.addItem(item)

            self.tabs.addTab(lw, f"{sheet} ({len(items)})")
            self._lists[sheet] = lw

        btn_ok = QPushButton("ОК")
        btn_cancel = QPushButton("Отмена")
        btn_ok.clicked.connect(self.accept)
        btn_cancel.clicked.connect(self.reject)

        hb = QHBoxLayout()
        hb.addStretch()
        hb.addWidget(btn_ok)
        hb.addWidget(btn_cancel)

        lay = QVBoxLayout(self)
        lay.addWidget(self.tabs)
        lay.addLayout(hb)

    def get_selected(self) -> list[dict]:
        res: list[dict] = []
        for lw in self._lists.values():
            res.extend(i.data(Qt.UserRole) for i in lw.selectedItems())
        return res


# ===================== Tests dialog =====================
class TestsDialog(QDialog):
    """Выбор тестов + кнопка калькулятора рядом с тестом 11."""
    def __init__(self, parent=None, items: List[str] | None = None,
                 selected: List[str] | None = None,
                 calc_launcher=None):
        super().__init__(parent)
        self.setWindowTitle("Выберите тесты")
        self.resize(600, 400)

        self.selection_order: List[int] = []
        self.calc_launcher = calc_launcher

        lay = QVBoxLayout(self)
        self.list = QListWidget(self)
        self.list.setSelectionMode(QAbstractItemView.MultiSelection)
        lay.addWidget(self.list)

        self._base_text_by_row: list[str] = []
        self._label_by_row: list[QLabel] = []

        rx_calc = re.compile(r"(?i)тест\s*11.*расход.*приточ", re.IGNORECASE)

        for txt in (items or []):
            item = QListWidgetItem()
            roww = QWidget()
            hb = QHBoxLayout(roww)
            hb.setContentsMargins(6, 2, 6, 2)

            lbl = QLabel(txt)
            hb.addWidget(lbl)
            hb.addStretch()

            if rx_calc.search(txt) and callable(self.calc_launcher):
                btn = QPushButton("Кальк.")
                btn.setToolTip("Открыть калькулятор Тест 11")
                btn.clicked.connect(self.calc_launcher)
                hb.addWidget(btn)

            self.list.addItem(item)
            self.list.setItemWidget(item, roww)
            item.setSizeHint(roww.sizeHint())

            self._base_text_by_row.append(txt)
            self._label_by_row.append(lbl)

        if selected:
            by_text = {t: i for i, t in enumerate(self._base_text_by_row)}
            for txt in selected:
                r = by_text.get(txt)
                if r is not None:
                    self.list.item(r).setSelected(True)
                    self.selection_order.append(r)

        btn_ok = QPushButton("ОК")
        btn_cancel = QPushButton("Отмена")
        btn_ok.clicked.connect(self.accept)
        btn_cancel.clicked.connect(self.reject)

        hb2 = QHBoxLayout()
        hb2.addStretch()
        hb2.addWidget(btn_ok)
        hb2.addWidget(btn_cancel)
        lay.addLayout(hb2)

        self.list.itemSelectionChanged.connect(self._on_selection_changed)
        self._renumber()

    def _on_selection_changed(self):
        current = {i.row() for i in self.list.selectedIndexes()}
        prev = set(self.selection_order)
        for r in list(self.selection_order):
            if r not in current:
                self.selection_order.remove(r)
        self.selection_order.extend(sorted(current - prev))
        self._renumber()

    def _renumber(self):
        for r, lbl in enumerate(self._label_by_row):
            lbl.setText(self._base_text_by_row[r])
        for n, r in enumerate(self.selection_order, start=1):
            lbl = self._label_by_row[r]
            base = self._base_text_by_row[r]
            lbl.setText(f"{n:02d}. {base}")

    def get_selected(self) -> List[str]:
        return [self._base_text_by_row[r] for r in self.selection_order]


# ===================== Appendix images (drag&drop + Ctrl+V) =====================
_ALLOWED_IMG_EXT = {".png", ".jpg", ".jpeg", ".bmp", ".tif", ".tiff", ".gif", ".pdf"}  # что можно выбрать/перетащить
DOCX_IMG_EXT = {".png", ".jpg", ".jpeg", ".gif", ".bmp"}  # что реально вставляет python-docx/docxtpl


class DropListWidget(QListWidget):
    def __init__(self, parent=None, *, paste_dir: Path | None = None, paste_prefix: str = "paste"):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)

        base = Path(paste_dir) if paste_dir else Path(tempfile.gettempdir()) / "doc_generator_app" / "pasted_images"
        base.mkdir(parents=True, exist_ok=True)
        self._paste_dir = base
        self._paste_prefix = paste_prefix

    def dragEnterEvent(self, e: QDragEnterEvent):
        if e.mimeData().hasUrls():
            e.acceptProposedAction()
        else:
            super().dragEnterEvent(e)

    def dragMoveEvent(self, e):
        if e.mimeData().hasUrls():
            e.acceptProposedAction()
        else:
            super().dragMoveEvent(e)

    def dropEvent(self, e: QDropEvent):
        if e.mimeData().hasUrls():
            paths: list[str] = []
            for url in e.mimeData().urls():
                p = url.toLocalFile()
                if not p:
                    continue
                ext = Path(p).suffix.lower()
                if ext in _ALLOWED_IMG_EXT and Path(p).exists():
                    paths.append(str(Path(p).resolve()))
            self._add_paths(paths)
            e.acceptProposedAction()
            return
        super().dropEvent(e)

    def keyPressEvent(self, e):
        if e.matches(QKeySequence.Paste):
            if self.paste_from_clipboard():
                return
        super().keyPressEvent(e)

    def paste_from_clipboard(self) -> bool:
        cb = QGuiApplication.clipboard()
        md = cb.mimeData()

        if md.hasImage():
            img = cb.image()
            if img.isNull():
                return False

            fname = f"{self._paste_prefix}_{datetime.now():%Y%m%d_%H%M%S}_{uuid.uuid4().hex[:8]}.png"
            out = (self._paste_dir / fname).resolve()
            ok = img.save(str(out), "PNG")
            if not ok:
                return False

            self._add_paths([str(out)])
            return True

        if md.hasUrls():
            paths: list[str] = []
            for url in md.urls():
                p = url.toLocalFile()
                if not p:
                    continue
                pp = Path(p)
                if pp.exists() and pp.suffix.lower() in _ALLOWED_IMG_EXT:
                    paths.append(str(pp.resolve()))
            if paths:
                self._add_paths(paths)
                return True

        return False

    def _add_paths(self, paths: list[str]):
        existing = set(self.get_paths())
        for p in paths:
            if p in existing:
                continue
            self.addItem(QListWidgetItem(p))
            existing.add(p)

    def get_paths(self) -> list[str]:
        return [self.item(i).text() for i in range(self.count())]


class AppendixImagesDialog(QDialog):
    def __init__(self, parent=None, title: str = "Загрузка изображений/скриншотов",
                 initial_paths: list[str] | None = None,
                 paste_prefix: str = "app"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.resize(760, 480)

        self.list = DropListWidget(self, paste_prefix=paste_prefix)
        if initial_paths:
            self.list._add_paths(initial_paths)

        self._sc_paste = QShortcut(QKeySequence.Paste, self)
        self._sc_paste.activated.connect(self._on_paste)

        hint = QLabel(
            "Перетащите файлы сюда или нажмите «Добавить…».\n"
            "Также можно вставить скриншот: Ctrl+V.\n"
            "Поддержка: PNG/JPG/BMP/TIFF/GIF/PDF.\n"
            "Важно: PDF/TIFF docxtpl вставлять не умеет — будут пропущены."
        )
        hint.setWordWrap(True)

        btn_add = QPushButton("Добавить…")
        btn_rm = QPushButton("Удалить выбранные")
        btn_clear = QPushButton("Очистить")

        btn_add.clicked.connect(self._add_files)
        btn_rm.clicked.connect(self._remove_selected)
        btn_clear.clicked.connect(self.list.clear)

        hb = QHBoxLayout()
        hb.addWidget(btn_add)
        hb.addWidget(btn_rm)
        hb.addWidget(btn_clear)
        hb.addStretch()

        btn_ok = QPushButton("ОК")
        btn_cancel = QPushButton("Отмена")
        btn_ok.clicked.connect(self.accept)
        btn_cancel.clicked.connect(self.reject)

        hb2 = QHBoxLayout()
        hb2.addStretch()
        hb2.addWidget(btn_ok)
        hb2.addWidget(btn_cancel)

        lay = QVBoxLayout(self)
        lay.addWidget(hint)
        lay.addWidget(self.list)
        lay.addLayout(hb)
        lay.addLayout(hb2)

    def _on_paste(self):
        if not self.list.paste_from_clipboard():
            QApplication.beep()

    def _add_files(self):
        files, _ = QFileDialog.getOpenFileNames(
            self,
            "Выберите файлы",
            os.getcwd(),
            "Images/PDF (*.png *.jpg *.jpeg *.bmp *.tif *.tiff *.gif *.pdf)"
        )
        if files:
            self.list._add_paths([str(Path(f).resolve()) for f in files])

    def _remove_selected(self):
        for it in list(self.list.selectedItems()):
            row = self.list.row(it)
            self.list.takeItem(row)

    def get_paths(self) -> list[str]:
        return self.list.get_paths()

from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn

def _cell_center_no_indent(cell):
    """
    Делает:
      - текст без табов/неразрывных пробелов
      - выравнивание по центру
      - убирает абзацные отступы
      - убирает внутренние поля ячейки (tcMar), которые обычно и дают "сдвиг"
      - фиксирует jc=center на уровне XML (чтобы стиль не перебил)
    """
    import re

    txt = (cell.text or "")
    txt = txt.replace("\t", "").replace("\u00A0", " ")
    txt = re.sub(r"\s+\n", "\n", txt)
    txt = re.sub(r"\n\s+", "\n", txt)
    txt = txt.strip()

    # ВАЖНО: text пересоздаёт абзацы -> форматируем уже после
    cell.text = txt

    # абзацы: центр + без отступов/таба
    for p in cell.paragraphs:
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER

        pf = p.paragraph_format
        pf.left_indent = 0
        pf.right_indent = 0
        pf.first_line_indent = 0
        pf.space_before = 0
        pf.space_after = 0

        pPr = p._p.get_or_add_pPr()

        # убрать tabs
        tabs = pPr.find(qn("w:tabs"))
        if tabs is not None:
            pPr.remove(tabs)

        # убрать ind
        ind = pPr.find(qn("w:ind"))
        if ind is not None:
            pPr.remove(ind)

        # жёстко: center в XML
        jc = pPr.find(qn("w:jc"))
        if jc is None:
            jc = OxmlElement("w:jc")
            pPr.append(jc)
        jc.set(qn("w:val"), "center")

    # убрать внутренние поля ячейки (это то, что чаще всего визуально мешает "центру")
    tcPr = cell._tc.get_or_add_tcPr()
    tcMar = tcPr.find(qn("w:tcMar"))
    if tcMar is None:
        tcMar = OxmlElement("w:tcMar")
        tcPr.append(tcMar)

    def _set_mar(tag: str):
        el = tcMar.find(qn(f"w:{tag}"))
        if el is None:
            el = OxmlElement(f"w:{tag}")
            tcMar.append(el)
        el.set(qn("w:w"), "0")
        el.set(qn("w:type"), "dxa")

    _set_mar("left")
    _set_mar("right")

    # опционально: вертикальный центр
    vAlign = tcPr.find(qn("w:vAlign"))
    if vAlign is None:
        vAlign = OxmlElement("w:vAlign")
        tcPr.append(vAlign)
    vAlign.set(qn("w:val"), "center")

# === Автозаполнение "Тест 11.2. Проверка кратности воздухообмена в ЧП" ===
def _fill_test_112(doc, rooms):
    import re

    def norm(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip().lower()

    # 1) находим таблицу теста 11.2
    t112 = None
    for t in doc.tables:
        if not t.rows:
            continue
        head = " ".join(c.text for c in t.rows[0].cells)
        h = norm(head)
        if ("тест" in h and ("11.2" in h or "11,2" in h)) and ("кратност" in h or "чп" in h):
            t112 = t
            break
    if t112 is None:
        return

    # 2) находим строку, где начинаются названия колонок (после "Результаты испытания")
    hdr_cols_row_idx = None
    for i, row in enumerate(t112.rows):
        line = norm(" ".join(c.text for c in row.cells))
        if "результаты испытани" in line:
            hdr_cols_row_idx = i + 1 if (i + 1) < len(t112.rows) else None
            break

    if hdr_cols_row_idx is None:
        for i, row in enumerate(t112.rows):
            line = norm(" ".join(c.text for c in row.cells))
            if ("номер" in line and "объем" in line) or ("общий расход" in line):
                hdr_cols_row_idx = i
                break

    if hdr_cols_row_idx is None:
        return

    # 3) ВАЖНО: из-за merge/gridSpan "Общий расход" может встречаться несколько раз.
    def find_cols(cells, *needles):
        out = []
        for ci, c in enumerate(cells):
            tt = norm(c.text)
            if all(n in tt for n in needles):
                out.append(ci)
        return out

    def find_col(cells, *needles):
        for ci, c in enumerate(cells):
            tt = norm(c.text)
            if all(n in tt for n in needles):
                return ci
        return None

    cols_row = t112.rows[hdr_cols_row_idx]
    col_totals = find_cols(cols_row.cells, "общий", "расход")     # <-- список
    col_fact = find_col(cols_row.cells, "фактическ")

    if not col_totals and col_fact is None:
        return

    # 4) Удаляем "пустую строку" от docxtpl (строка где был отдельный {% for %})
    def is_spacer(row):
        return all(norm(c.text) in ("", "¤") for c in row.cells)

    # Шапка занимает 2 строки: заголовки + подзаголовки
    data_start = hdr_cols_row_idx + 2

    while data_start < len(t112.rows) and is_spacer(t112.rows[data_start]):
        t112._tbl.remove(t112.rows[data_start]._tr)

    # 5) граница данных - до "КОММЕНТАРИИ"
    data_end = len(t112.rows)
    for i in range(data_start, len(t112.rows)):
        first_cell = norm(t112.rows[i].cells[0].text)
        if first_cell.startswith("комментар"):
            data_end = i
            break
    if data_end <= data_start:
        return

    # 6) если помещений больше, чем строк - дополняем копиями последней строки данных
    need = len(rooms)
    have = data_end - data_start
    if need > have:
        from copy import deepcopy
        sample_tr = deepcopy(t112.rows[data_end - 1]._tr)
        for _ in range(need - have):
            t112._tbl.append(deepcopy(sample_tr))
        data_end = data_start + need

    # 7) заполняем
    for idx, room in enumerate(rooms):
        r = data_start + idx
        if r >= len(t112.rows):
            break

        row = t112.rows[r]
        total_flow = (room.get("total_flow") or "").strip()
        exch_act = (room.get("exchange_actual") or "").strip()

        # общий расход: записываем (если есть) и ВСЕГДА форматируем все найденные колонки
        for ci in col_totals:
            if ci < len(row.cells):
                cell = row.cells[ci]
                if total_flow:
                    cell.text = total_flow
                _cell_center_no_indent(cell)

        # фактическая: заполняем как было
        if col_fact is not None and col_fact < len(row.cells) and exch_act:
            row.cells[col_fact].text = exch_act



from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
import re





# ===================== DOCX equipment date postprocess =====================
def _fix_weird_ddmmyyyy(s: str) -> str:
    m = re.match(r"^(\d{1,2})\.(\d{2})(\d{4})$", s)
    if m:
        return f"{m.group(1)}.{m.group(2)}.{m.group(3)}"
    return s


def _parse_date_any(s: str):
    s = (s or "").strip().replace("\u00a0", " ")
    s = re.sub(r"\s+", " ", s).replace("г.", "").replace("г", "").strip(" .")
    if not s:
        return None

    s = s.split()[0]
    s = _fix_weird_ddmmyyyy(s)

    fmts = ["%Y-%m-%d", "%d.%m.%Y", "%d-%m-%Y", "%Y.%m.%d", "%d/%m/%Y", "%Y/%m/%d"]
    for fmt in fmts:
        try:
            return datetime.strptime(s, fmt).date()
        except Exception:
            pass

    m = re.match(r"^(\d{4})-(\d{1,2})-(\d{1,2})$", s)
    if m:
        try:
            return date(int(m.group(1)), int(m.group(2)), int(m.group(3)))
        except Exception:
            return None

    m = re.match(r"^(\d{1,2})\.(\d{1,2})\.(\d{4})$", s)
    if m:
        try:
            return date(int(m.group(3)), int(m.group(2)), int(m.group(1)))
        except Exception:
            return None

    return None


def _fmt_date(d: date) -> str:
    return d.strftime("%d.%m.%Y")


def _format_date_range_cell(text: str) -> str:
    if not text or not text.strip():
        return text

    raw = re.sub(r"\s*\n\s*", " ", text).strip()

    if "/" in raw:
        parts = [p.strip() for p in raw.split("/") if p.strip()]
        if len(parts) >= 2:
            d1 = _parse_date_any(parts[0])
            d2 = _parse_date_any(parts[1])
            if d1 and d2:
                return f"{_fmt_date(d1)} / {_fmt_date(d2)}"
            return raw

    date_like = re.findall(
        r"\d{4}-\d{1,2}-\d{1,2}|\d{1,2}\.\d{1,2}\.\d{4}|\d{1,2}\.\d{2}\d{4}",
        raw
    )
    if len(date_like) >= 2:
        d1 = _parse_date_any(date_like[0])
        d2 = _parse_date_any(date_like[1])
        if d1 and d2:
            return f"{_fmt_date(d1)} / {_fmt_date(d2)}"

    d = _parse_date_any(raw)
    if d:
        return _fmt_date(d)

    return raw


def postprocess_equipment_dates(doc) -> None:
    """
    Ищет в документе столбец 'Дата поверки/ Действительно до:' и
    форматирует значения в 'ДД.ММ.ГГГГ / ДД.ММ.ГГГГ'.
    """
    def norm(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip().lower()

    hdr_needle = "дата поверки/ действительно до"
    for t in doc.tables:
        if not t.rows:
            continue

        hdr_row_idx = None
        for ri in range(min(3, len(t.rows))):
            row_text = " ".join(c.text for c in t.rows[ri].cells)
            if hdr_needle in norm(row_text):
                hdr_row_idx = ri
                break
        if hdr_row_idx is None:
            continue

        col_idx = None
        for ci, c in enumerate(t.rows[hdr_row_idx].cells):
            if hdr_needle in norm(c.text):
                col_idx = ci
                break
        if col_idx is None:
            continue

        for ri in range(hdr_row_idx + 1, len(t.rows)):
            cell = t.rows[ri].cells[col_idx]
            old = cell.text
            new = _format_date_range_cell(old)
            if new != old:
                cell.text = new


def update_fields_only_with_word(docx_path: str) -> None:
    """Обновляет поля Word (NUMPAGES и т.п.) через COM. Требует pywin32 и MS Word."""
    import win32com.client as win32

    word = win32.gencache.EnsureDispatch("Word.Application")
    word.Visible = False
    try:
        doc = word.Documents.Open(str(docx_path))
        doc.Repaginate()
        doc.Fields.Update()
        for sec in doc.Sections:
            sec.Headers(1).Range.Fields.Update()
            sec.Footers(1).Range.Fields.Update()
        doc.Save()
        doc.Close()
    finally:
        word.Quit()


# ===================== Render Worker =====================



# ===================== Main Window =====================
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Генератор OQ/PQ — PySide6 + DocxTemplate")

        base = Path.cwd()
        self.defaults = {
            "OQ": {
                "tpl": base / "Шаблон OQ.docx",
                "tests": base / "Тесты OQ.docx",
                "xls_tests": base / "tests OQ.xlsx",
                "xls_eq": base / "ПЕРЕЧЕНЬ ПРИБОРОВ OQ.xlsx",
                "scans_dir": base / "Сканы поверок"
            },
            "PQ": {
                "tpl": base / "Шаблон PQ.docx",
                "tests": base / "Тесты PQ.docx",
                "xls_tests": base / "tests PQ.xlsx",
                "xls_eq": base / "ПЕРЕЧЕНЬ ПРИБОРОВ OQ.xlsx",
                "scans_dir": base / "Сканы поверок"
            },
        }

        self.rooms: List[Dict[str, str]] = []
        self.equipment: List[Dict[str, str]] = []
        self.all_tests: List[str] = []
        self.selected_tests: List[str] = []
        self._batch_modes: List[str] = []

        self.app1_images: list[str] = []
        self.app4_images: list[str] = []

        self._build_ui()
        self.on_mode_changed("OQ")

    def _build_ui(self) -> None:
        cw = QWidget()
        g = QGridLayout()
        g.setSpacing(10)
        row = 0

        g.addWidget(QLabel("Режим:"), row, 0)
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(["OQ", "PQ", "OQ и PQ"])
        self.mode_combo.currentTextChanged.connect(self.on_mode_changed)
        g.addWidget(self.mode_combo, row, 1, 1, 2)
        row += 1

        g.addWidget(QLabel("Шаблон (.docx):"), row, 0)
        self.tpl_path = QLineEdit()
        self.tpl_path.setReadOnly(True)
        g.addWidget(self.tpl_path, row, 1, 1, 1)
        btn_browse_tpl = QPushButton("…")
        btn_browse_tpl.clicked.connect(lambda: self._select(self.tpl_path, "Word Documents (*.docx)", save=False))
        g.addWidget(btn_browse_tpl, row, 2)
        row += 1

        g.addWidget(QLabel("Документ-тесты (.docx):"), row, 0)
        self.tests_path = QLineEdit()
        g.addWidget(self.tests_path, row, 1, 1, 1)
        btn_browse_tests = QPushButton("…")
        btn_browse_tests.clicked.connect(lambda: self._select(self.tests_path, "Word Documents (*.docx)", save=False))
        g.addWidget(btn_browse_tests, row, 2)
        row += 1

        btn_calc11 = QPushButton("Калькулятор Тест 11 (расход)…")
        btn_calc11.clicked.connect(self.launch_test11_calculator)
        g.addWidget(btn_calc11, row, 0, 1, 3)
        row += 1

        g.addWidget(QLabel("Excel с тестами:"), row, 0)
        self.xls_path = QLineEdit()
        self.xls_path.setReadOnly(True)
        g.addWidget(self.xls_path, row, 1, 1, 1)
        btn_browse_xls = QPushButton("…")
        btn_browse_xls.clicked.connect(lambda: self._select(self.xls_path, "Excel Files (*.xlsx)", save=False))
        g.addWidget(btn_browse_xls, row, 2)
        row += 1

        self.tests_btn = QPushButton("Выбрать тесты…")
        self.tests_btn.clicked.connect(self.choose_tests)
        g.addWidget(self.tests_btn, row, 0, 1, 3)
        row += 1

        g.addWidget(QLabel("Excel-оборудование:"), row, 0)
        self.equipment_xls_path = QLineEdit()
        self.equipment_xls_path.setReadOnly(True)
        g.addWidget(self.equipment_xls_path, row, 1, 1, 1)
        btn_eq = QPushButton("Загрузить оборудование")
        btn_eq.clicked.connect(lambda: self.load_equipment(silent=False))
        g.addWidget(btn_eq, row, 2)
        row += 1

        btn_rooms = QPushButton("Настройки помещений…")
        btn_rooms.clicked.connect(self.edit_rooms)
        g.addWidget(btn_rooms, row, 0, 1, 3)
        row += 1

        g.addWidget(QLabel("Папка со сканами (поверки):"), row, 0)
        self.scans_dir_input = QLineEdit()
        g.addWidget(self.scans_dir_input, row, 1, 1, 1)
        btn_dir = QPushButton("…")
        btn_dir.clicked.connect(lambda: self._select_dir(self.scans_dir_input))
        g.addWidget(btn_dir, row, 2)
        row += 1

        g.addWidget(QLabel("Приложение 1 (картинки/скриншоты):"), row, 0, Qt.AlignTop)
        self.app1_btn = QPushButton("Выбрать / перетащить файлы…")
        self.app1_btn.clicked.connect(self.choose_app1_images)
        g.addWidget(self.app1_btn, row, 1, 1, 2)
        row += 1

        self.app1_info = QLabel("Файлы не выбраны")
        self.app1_info.setWordWrap(True)
        g.addWidget(self.app1_info, row, 1, 1, 2)
        row += 1

        g.addWidget(QLabel("Приложение 4 (картинки/скриншоты):"), row, 0, Qt.AlignTop)
        self.app4_btn = QPushButton("Выбрать / перетащить файлы…")
        self.app4_btn.clicked.connect(self.choose_app4_images)
        g.addWidget(self.app4_btn, row, 1, 1, 2)
        row += 1

        self.app4_info = QLabel("Файлы не выбраны")
        self.app4_info.setWordWrap(True)
        g.addWidget(self.app4_info, row, 1, 1, 2)
        row += 1

        fields = [
            ("Объект:", "object_input"), ("ПРТ:", "prt_input"),
            ("Год:", "year_input"), ("Заказчик:", "customer_input"),
            ("Адрес объекта:", "address_input"),
            ("Разработал:", "developed_input"), ("Проверил:", "checked_input"),
        ]
        for label, attr in fields:
            g.addWidget(QLabel(label), row, 0)
            le = QLineEdit()
            setattr(self, attr, le)
            g.addWidget(le, row, 1, 1, 2)
            row += 1

        dates = [
            ("Дата разработки:", "date_dev"),
            ("Дата проверки:", "date_check"),
            ("Дата начала испытания:", "date_test"),
            ("Дата окончания:", "date_end"),
        ]
        for label, attr in dates:
            g.addWidget(QLabel(label), row, 0)
            de = QDateEdit(calendarPopup=True)
            de.setDate(date.today())
            setattr(self, attr, de)
            g.addWidget(de, row, 1, 1, 2)
            row += 1

        g.addWidget(QLabel("Сохранить как (.docx):"), row, 0)
        self.out_path = QLineEdit()
        g.addWidget(self.out_path, row, 1, 1, 1)
        btn_save = QPushButton("…")
        btn_save.clicked.connect(lambda: self._select(self.out_path, "Word Documents (*.docx)", save=True))
        g.addWidget(btn_save, row, 2)
        row += 1

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 12)
        g.addWidget(self.progress_bar, row, 0, 1, 3)
        row += 1

        btn_generate = QPushButton("Сгенерировать")
        btn_generate.clicked.connect(self.start_render)
        g.addWidget(btn_generate, row, 0, 1, 3)

        cw.setLayout(g)
        self.setCentralWidget(cw)

    def _select(self, widget: QLineEdit, flt: str, save: bool = False) -> None:
        if save:
            path, _ = QFileDialog.getSaveFileName(self, "Сохранить файл", os.getcwd(), flt)
        else:
            path, _ = QFileDialog.getOpenFileName(self, "Выберите файл", os.getcwd(), flt)
        if path:
            widget.setText(path)

    def _select_dir(self, widget: QLineEdit) -> None:
        d = QFileDialog.getExistingDirectory(self, "Выберите папку со сканами", os.getcwd())
        if d:
            widget.setText(d)

    def choose_app1_images(self):
        dlg = AppendixImagesDialog(
            self,
            title="Приложение 1 — загрузка изображений/скриншотов",
            initial_paths=self.app1_images,
            paste_prefix="app1"
        )
        if dlg.exec() == QDialog.Accepted:
            self.app1_images = dlg.get_paths()
            self.app1_info.setText(f"Выбрано файлов: {len(self.app1_images)}")

    def choose_app4_images(self):
        dlg = AppendixImagesDialog(
            self,
            title="Приложение 4 — загрузка изображений/скриншотов",
            initial_paths=self.app4_images,
            paste_prefix="app4"
        )
        if dlg.exec() == QDialog.Accepted:
            self.app4_images = dlg.get_paths()
            self.app4_info.setText(f"Выбрано файлов: {len(self.app4_images)}")

    def on_mode_changed(self, mode: str) -> None:
        if mode in ("ОQ и PQ", "OQ и PQ"):
            self.tpl_path.setText("")
            self.tests_path.setText("")
            self.xls_path.setText("")
            self.equipment_xls_path.setText("")
            self.scans_dir_input.setText("")
            return

        d = self.defaults[mode]
        self.tpl_path.setText(str(d["tpl"]))
        self.tests_path.setText(str(d["tests"]))
        self.xls_path.setText(str(d["xls_tests"]))
        self.equipment_xls_path.setText(str(d["xls_eq"]))
        self.scans_dir_input.setText(str(d["scans_dir"]))
        self.load_tests(silent=True)
        self.load_equipment(silent=True)

    def load_tests(self, silent: bool = False) -> None:
        try:
            path = Path(self.xls_path.text())
            self.all_tests = io_manager.load_tests_list(path)
            self.selected_tests = []
            if not silent:
                QMessageBox.information(self, "Тесты загружены", f"Всего тестов: {len(self.all_tests)}")
        except Exception as e:
            QMessageBox.critical(self, "Ошибка загрузки тестов", str(e))

    def choose_tests(self) -> None:
        if not self.all_tests:
            QMessageBox.warning(self, "Нет тестов", "Тесты не загружены!")
            return

        dlg = TestsDialog(self, self.all_tests, self.selected_tests,
                          calc_launcher=self.launch_test11_calculator)
        if dlg.exec() == QDialog.Accepted:
            self.selected_tests = dlg.get_selected()

    def load_equipment(self, silent: bool = False) -> None:
        try:
            path = Path(self.equipment_xls_path.text())
            by_sheets = io_manager.load_equipment_by_sheets(path)
            if silent:
                self.equipment = [it for items in by_sheets.values() for it in items]
                return
            dlg = EquipmentDialog(self, by_sheets)
            if dlg.exec() == QDialog.Accepted:
                self.equipment = dlg.get_selected()
        except Exception as e:
            QMessageBox.critical(self, "Ошибка загрузки оборудования", str(e))

    def edit_rooms(self) -> None:
        dlg = RoomsDialog(self, self.rooms)
        if dlg.exec() == QDialog.Accepted:
            self.rooms = dlg.get_rooms()

    def launch_test11_calculator(self, *_, auto_close: bool = True) -> int:
        import subprocess

        tpl_path_str = (self.tests_path.text().strip() or "")
        if not tpl_path_str:
            QMessageBox.critical(self, "Калькулятор Тест 11", "Не указан «Документ-тесты (.docx)».")
            return 1

        tpl_path = Path(tpl_path_str).expanduser().resolve()
        if not tpl_path.exists():
            QMessageBox.critical(self, "Калькулятор Тест 11", f"Файл не найден:\n{tpl_path}")
            return 1

        rooms: List[Dict[str, Any]] = list(self.rooms) if getattr(self, "rooms", None) else []
        n = max(1, len(rooms) or 1)

        def _get(room: Dict[str, Any], key: str, default: str) -> str:
            v = room.get(key)
            s = "" if v is None else str(v).strip()
            return s if s else default

        nums = [_get(r, "num", f"{i + 1}") for i, r in enumerate(rooms[:n])]
        names = [_get(r, "name", "") for r in rooms[:n]]
        areas = [_get(r, "area", "1") for r in rooms[:n]]
        filters = [_get(r, "filters", "2") for r in rooms[:n]]
        points = [_get(r, "points", "2") for r in rooms[:n]]
        airflows = [_get(r, "airflow", "") for r in rooms[:n]]

        def _pad(lst, filler):
            need = n - len(lst)
            return lst if need <= 0 else lst + [filler(len(lst) + k + 1) for k in range(need)]

        nums = _pad(nums, lambda k: str(k))
        names = _pad(names, lambda _: "")
        areas = _pad(areas, lambda _: "1")
        filters = _pad(filters, lambda _: "2")
        points = _pad(points, lambda _: "2")
        airflows = _pad(airflows, lambda _: "")

        def _join(xs: List[str]) -> str:
            return ";".join(x.replace(";", " ").strip() for x in xs)

        nums_s, names_s, areas_s = _join(nums), _join(names), _join(areas)
        filters_s, points_s = _join(filters), _join(points)
        airflows_s = _join(airflows)

        proj_root = Path(__file__).resolve().parents[1]
        candidates = [
            proj_root / "tools" / "test11_airflow_calc.py",
            Path.cwd() / "tools" / "test11_airflow_calc.py",
            proj_root / "tests" / "test11_airflow_calc.py",
            Path(__file__).resolve().parent / "test11_airflow_calc.py",
        ]
        script = next((p for p in candidates if p.exists()), None)
        if script is None:
            paths_list = "\n".join(str(p) for p in candidates)
            QMessageBox.critical(
                self, "Калькулятор Тест 11",
                "Не найден скрипт test11_airflow_calc.py по путям:\n\n" + paths_list
            )
            return 1

        tmp_dir = Path(tempfile.mkdtemp(prefix="test11_"))
        auto_save_path = tmp_dir / "test11_auto_save.docx"

        args: List[str] = [
            sys.executable, str(script),
            "--template", str(tpl_path),
            "--rooms", str(n),
            "--nums", nums_s,
            "--names", names_s,
            "--areas", areas_s,
            "--filters", filters_s,
            "--points", points_s,
            "--airflows", airflows_s,
            "--auto-save", str(auto_save_path),
        ]
        if auto_close:
            args.append("--auto-close")

        try:
            proc = subprocess.run(args, check=False)
            rc = int(proc.returncode or 0)
        except Exception as e:
            QMessageBox.critical(self, "Калькулятор Тест 11", f"Ошибка запуска:\n{e}")
            return 1

        if auto_save_path.exists():
            self.tests_path.setText(str(auto_save_path))

        setattr(self, "last_test11_autosave", str(auto_save_path))
        return rc

    def start_render(self) -> None:
        mode = self.mode_combo.currentText()
        if mode == "OQ и PQ":
            self._batch_modes = ["OQ", "PQ"]
            self._start_single_render(self._batch_modes.pop(0))
        else:
            self._batch_modes = []
            self._start_single_render(mode)

    def _start_single_render(self, mode: str) -> None:
        mode = mode.upper()
        use_ui_paths = (self.mode_combo.currentText().upper() == mode)

        if use_ui_paths:
            tpl_path = self.tpl_path.text().strip()
            tests_path = self.tests_path.text().strip()
            xls_tests = self.xls_path.text().strip()
            xls_eq = self.equipment_xls_path.text().strip()
            scans_dir = self.scans_dir_input.text().strip()
            sel_tests_raw = self.selected_tests[:]
            equipment_list = self.equipment[:]
        else:
            d = self.defaults[mode]
            tpl_path = str(d["tpl"])
            tests_path = str(d["tests"])
            xls_tests = str(d["xls_tests"])
            xls_eq = str(d["xls_eq"])
            scans_dir = str(d["scans_dir"])
            try:
                sel_tests_raw = io_manager.load_tests_list(Path(xls_tests))
            except Exception as e:
                QMessageBox.critical(self, f"Ошибка загрузки тестов ({mode})", str(e))
                return
            try:
                by_sheets = io_manager.load_equipment_by_sheets(Path(xls_eq))
                equipment_list = [it for items in by_sheets.values() for it in items]
            except Exception as e:
                QMessageBox.critical(self, f"Ошибка загрузки оборудования ({mode})", str(e))
                return

        app1_images = self.app1_images[:]
        app4_images = self.app4_images[:]

        out_base = Path(self.out_path.text().strip())
        if not out_base.name:
            QMessageBox.critical(self, "Ошибка", "Не указан путь сохранения")
            return
        out_path = out_base.with_name(out_base.stem + f"_{mode}.docx")

        missing_fields = []
        if not tpl_path: missing_fields.append("шаблон")
        if not tests_path: missing_fields.append("документ-тесты")
        if not xls_tests: missing_fields.append("Excel с тестами")
        if not xls_eq: missing_fields.append("Excel оборудование")
        if missing_fields:
            QMessageBox.critical(self, f"Ошибка ({mode})", "Не указаны: " + ", ".join(missing_fields))
            return

        sel_tests = [
            re.sub(r"(?i)^тест\s*\d+(?:\.\d+)?\.?\s*", "", s).strip()
            for s in sel_tests_raw if isinstance(s, str) and s.strip()
        ]

        raw_prt = self.prt_input.text().strip()
        prt_norm = raw_prt.upper()
        for pref in ("ПРТ-OQ-", "ПРТ-PQ-"):
            prt_norm = prt_norm.replace(pref, "")
        full_prt = f"ПРТ-{mode}-{prt_norm}" if prt_norm else ""
        prt = RichText(full_prt, bold=False, italic=False, underline=False)

        object_text = self.object_input.text().strip()
        object_rd = ""
        if object_text:
            morph = MorphAnalyzer()
            words = object_text.split()
            parsed = [morph.parse(w)[0] for w in words]
            adj_idx = next((i for i, p in enumerate(parsed[:-1]) if 'ADJF' in p.tag), None)
            noun_idx = adj_idx + 1 if adj_idx is not None and adj_idx + 1 < len(parsed) else None
            if adj_idx is not None and noun_idx is not None and 'NOUN' in parsed[noun_idx].tag:
                adj = parsed[adj_idx]
                noun = parsed[noun_idx]
                gender = noun.tag.gender
                number = noun.tag.number
                adj_gent = adj.inflect({'gent', gender, number})
                noun_gent = noun.inflect({'gent'})
                if adj_gent and noun_gent:
                    before = " ".join(words[:adj_idx])
                    after = " ".join(words[noun_idx + 1:])
                    object_rd = f"{before} {adj_gent.word} {noun_gent.word} {after}".strip()
                else:
                    object_rd = object_text
            else:
                first_noun = next((p for p in parsed if 'NOUN' in p.tag), None)
                if first_noun:
                    infl = first_noun.inflect({'gent'})
                    if infl:
                        idx = parsed.index(first_noun)
                        object_rd = " ".join(words[:idx] + [infl.word] + words[idx + 1:])
                    else:
                        object_rd = object_text
                else:
                    object_rd = object_text

        ctx_fields: Dict[str, Any] = {
            "объект": object_text,
            "объект1": object_rd,
            "prt": prt,
            "year": self.year_input.text().strip(),
            "customer": self.customer_input.text().strip(),
            "address": self.address_input.text().strip(),
            "Разработал": self.developed_input.text().strip(),
            "Проверил": self.checked_input.text().strip(),
            "Дата_Разработки": self.date_dev.date().toString("dd.MM.yyyy"),
            "Дата_Проверки": self.date_check.date().toString("dd.MM.yyyy"),
            "ДАТА_начала_испытания": self.date_test.date().toString("dd.MM.yyyy"),
            "ДАТА_окончания": self.date_end.date().toString("dd.MM.yyyy"),
            "Тесты_маркированным_списком": RichText("\n".join(f"• {t}" for t in sel_tests), bold=False),
        }

        self.setEnabled(False)
        self.progress_bar.setValue(0)

        self.worker = RenderWorker(
            tpl_path, tests_path, xls_tests, xls_eq, str(out_path),
            sel_tests, self.rooms, equipment_list, ctx_fields,
            scans_dir=scans_dir,
            app1_images=app1_images,
            app4_images=app4_images,
        )
        self.worker.progress.connect(self.on_progress)
        self.worker.finished.connect(self.on_finished)
        self.worker.start()

    def on_progress(self, step: int, message: str) -> None:
        self.progress_bar.setValue(step)
        self.statusBar().showMessage(message)

    def on_finished(self, success: bool, message: str, missing: list[str]) -> None:
        if self._batch_modes:
            next_mode = self._batch_modes.pop(0)
            if success:
                if missing:
                    QMessageBox.warning(self, "Внимание", "Не вставлены тесты:\n" + "\n".join(missing))
                logger.info(message)
            else:
                QMessageBox.critical(self, "Ошибка", message)
                self._batch_modes.clear()
                self.setEnabled(True)
                self.statusBar().clearMessage()
                return
            self._start_single_render(next_mode)
            return

        self.setEnabled(True)
        if success:
            if missing:
                QMessageBox.warning(self, "Внимание", "Не вставлены тесты:\n" + "\n".join(missing))
            QMessageBox.information(self, "Успех", message)
        else:
            QMessageBox.critical(self, "Ошибка", message)
        self.statusBar().clearMessage()


def main():
    app = QApplication(sys.argv)
    wnd = MainWindow()
    wnd.resize(900, 760)
    wnd.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()


from PySide6.QtWidgets import QMainWindow, QLabel
from PySide6.QtCore import Qt

class OldCleanroomWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Старый режим — Чистые помещения")
        label = QLabel("Режим чистых помещений пока реализован в старом виде.")
        label.setAlignment(Qt.AlignCenter)
        self.setCentralWidget(label)


def launch_old_app():
    return OldCleanroomWindow()


# ui/rooms_table.py  (новый файл)
from PySide6.QtWidgets import QTableWidget, QTableWidgetItem, QApplication
from PySide6.QtCore import Qt

class SpreadsheetTable(QTableWidget):
    """
    QTableWidget с excel-копипастой:
      • Ctrl+C — копирует текущее выделение как TSV
      • Ctrl+V — вставляет прямоугольный блок (TSV/CSV/строки)
      • если нет выделения — работаем от (0,0)
      • автоматически добавляет недостающие строки
    """
    def keyPressEvent(self, e):
        ctrl = e.modifiers() & Qt.ControlModifier
        if ctrl and e.key() == Qt.Key_C:
            self._copy_selection_to_clipboard()
            return
        if ctrl and e.key() == Qt.Key_V:
            self._paste_from_clipboard()
            return
        super().keyPressEvent(e)

    # --- helpers ---
    def _copy_selection_to_clipboard(self):
        rngs = self.selectedRanges()
        if rngs:
            r = rngs[0]
            rows = range(r.topRow(), r.bottomRow() + 1)
            cols = range(r.leftColumn(), r.rightColumn() + 1)
        else:
            # нет выделения — копируем всё содержимое
            rows = range(0, self.rowCount())
            cols = range(0, self.columnCount())

        lines = []
        for i in rows:
            vals = []
            for j in cols:
                it = self.item(i, j)
                vals.append("" if it is None else it.text())
            lines.append("\t".join(vals))
        QApplication.clipboard().setText("\n".join(lines))

    def _paste_from_clipboard(self):
        text = QApplication.clipboard().text()
        if not text:
            return

        # поддержка TSV/CSV
        rows_data = [
            [c.strip() for c in row.replace(";", "\t").split("\t")]
            for row in text.splitlines()
            if row.strip() != ""
        ]
        if not rows_data:
            return

        # точка вставки — левый верх выделения, иначе (0,0)
        rngs = self.selectedRanges()
        start_row = rngs[0].topRow() if rngs else 0
        start_col = rngs[0].leftColumn() if rngs else 0

        needed_rows = start_row + len(rows_data)
        if self.rowCount() < needed_rows:
            self.setRowCount(needed_rows)

        needed_cols = start_col + max(len(r) for r in rows_data)
        if self.columnCount() < needed_cols:
            self.setColumnCount(needed_cols)

        for i, row_vals in enumerate(rows_data):
            for j, val in enumerate(row_vals):
                r = start_row + i
                c = start_col + j
                it = self.item(r, c)
                if it is None:
                    it = QTableWidgetItem()
                    self.setItem(r, c, it)
                it.setText(val)


# ui/startup_dialog.py
from PySide6.QtWidgets import QDialog, QVBoxLayout, QPushButton

class StartupDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Выберите режим работы")
        self.resize(300, 150)
        self.choice = None

        layout = QVBoxLayout(self)

        btn_eq = QPushButton("Оборудование")
        btn_cr = QPushButton("Чистые помещения")

        btn_eq.clicked.connect(lambda: self._select("equipment"))
        btn_cr.clicked.connect(lambda: self._select("cleanrooms"))

        layout.addWidget(btn_eq)
        layout.addWidget(btn_cr)

    def _select(self, choice):
        self.choice = choice
        self.accept()

    def get_choice(self):
        return self.choice


from PySide6.QtWidgets import QApplication

def apply_compact_style(app: QApplication) -> None:
    app.setStyle("Fusion")
    app.setStyleSheet("""
        QWidget { font-size: 10pt; }
        QLineEdit, QComboBox, QDateEdit {
            padding: 5px 8px;
            border-radius: 6px;
        }
        QPushButton {
            padding: 6px 10px;
            border-radius: 6px;
        }
        QToolButton {
            padding: 4px 6px;
            border-radius: 6px;
        }
        QGroupBox {
            margin-top: 10px;
            font-weight: 600;
        }
        QGroupBox::title {
            subcontrol-origin: margin;
            left: 10px;
            padding: 0 4px;
        }
    """)



# risk_table5.py
from __future__ import annotations

import re
from copy import deepcopy
from typing import Dict, List, Tuple, Optional

from openpyxl import load_workbook

from docx.document import Document as DocxDocument
from docx.table import Table, _Cell
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Pt
from docx.oxml import OxmlElement
from docx.oxml.ns import qn


# =============================================================================
# Нормализация / сравнение тестов (очень важно для совпадений)
# =============================================================================

def _norm_basic(s: str) -> str:
    s = "" if s is None else str(s)
    s = (
        s.replace("\u00A0", " ")   # nbsp
        .replace("\u202F", " ")   # narrow nbsp
        .replace("\u200B", "")    # zero-width
        .replace("\u00AD", "")    # soft hyphen
    )
    s = re.sub(r"\s+", " ", s).strip().lower()
    s = s.replace("ё", "е")
    return s


def _match_key(s: str) -> str:
    """
    Ключ для сравнения: выкидываем пробелы/пунктуацию.
    Тогда совпадут:
      "обучении/ ознакомлении" и "обучении / ознакомлении"
      с точками/без точек и т.п.
    """
    return re.sub(r"[^0-9a-zа-я]+", "", _norm_basic(s))


def _split_tests_cell(s: str) -> List[str]:
    """
    В Excel в 'Аттестационное испытание' может быть:
    - одно название
    - несколько через перенос строки / ;
    """
    raw = _norm_basic(s)
    if not raw:
        return []

    # но возвращаем ОРИГИНАЛЬНЫЕ части (не lower), поэтому парсим по исходной строке
    src = (s or "").replace("\u00A0", " ").strip()
    parts = re.split(r"[\n;]+", src)
    out: List[str] = []
    for p in parts:
        p = p.strip(" \t\r,")
        if p:
            out.append(p)
    return out


def _selected_tests_to_names(selected_tests: List[str]) -> List[str]:
    """
    selected_tests приходит из UI иногда с префиксами:
      '01. Тест 11.1 ...'
    Нам нужна "чистая" часть (как в Excel).
    """
    names: List[str] = []
    for t in selected_tests or []:
        t0 = (t or "").strip()
        if not t0:
            continue

        # убрать "01."
        t0 = re.sub(r"^\s*\d+\s*\.\s*", "", t0)

        # убрать "Тест 11.1" / "Тест 11" и т.п.
        t0 = re.sub(r"^\s*тест\s*\d+(?:\.\d+)?\.?\s*", "", t0, flags=re.IGNORECASE)

        names.append(t0.strip())
    return names


def _is_match(selected_name: str, test_from_excel: str) -> bool:
    """
    Матч "вхождение ключа" в любую сторону.
    """
    sk = _match_key(selected_name)
    tk = _match_key(test_from_excel)
    if not sk or not tk:
        return False
    return (sk in tk) or (tk in sk)


# =============================================================================
# Excel: чтение строк
# =============================================================================

def _build_header_map(ws) -> Dict[str, int]:
    """
    Мапа "нормализованный заголовок" -> индекс колонки (1-based).
    Считаем, что заголовок в 1-й строке.
    """
    header_map: Dict[str, int] = {}
    for c in range(1, ws.max_column + 1):
        v = ws.cell(row=1, column=c).value
        if v is None:
            continue
        header_map[_norm_basic(str(v))] = c
    return header_map


def _h(header_map: Dict[str, int], *variants: str) -> int | None:
    for v in variants:
        k = _norm_basic(v)
        if k in header_map:
            return header_map[k]
    return None


def get_risk_rows(xlsx_path: str, selected_tests: List[str]) -> List[Dict[str, str]]:
    """
    Возвращает строки для Таблицы 5:
    - берём только те строки Excel, где в "Аттестационное испытание" есть хотя бы 1 выбранный тест
    - ВНУТРИ строки оставляем только выбранные тесты (в порядке выбора пользователем)
    - одинаковые строки (по всем полям кроме тестов) схлопываем, объединяя тесты
    """
    wb = load_workbook(xlsx_path, data_only=True)
    ws = wb.active

    header_map = _build_header_map(ws)

    cols = {
        "risk": _h(header_map, "Риск"),
        "cause": _h(header_map, "Возможная причина"),
        "prob_l": _h(header_map, "Вероятность_оценка", "Вероятность оценка"),
        "prob_s": _h(header_map, "Вероятность_балл", "Вероятность балл"),
        "sev_l": _h(header_map, "Тяжесть_оценка", "Тяжесть оценка"),
        "sev_s": _h(header_map, "Тяжесть_балл", "Тяжесть балл"),
        "det_l": _h(header_map, "Необнаружение_оценка", "Необнаружение оценка"),
        "det_s": _h(header_map, "Необнаружение_балл", "Необнаружение балл"),
        "level_l": _h(header_map, "Уровень_риска", "Уровень риска"),
        "rpn": _h(header_map, "ПЧР", "RPN"),
        "tests": _h(header_map, "Аттестационное испытание", "Квалификационное испытание"),
    }

    if any(v is None for v in cols.values()):
        raise ValueError(f"Не найдены все нужные колонки в Excel (ожидается строка 1). Найдено: {cols}")

    sel_names = _selected_tests_to_names(selected_tests)
    sel_names = [s for s in sel_names if s.strip()]  # сохранить порядок выбора

    def sval(v) -> str:
        return "" if v is None else str(v).strip()

    def ival(v) -> str:
        if v is None:
            return ""
        s = str(v).strip()
        # 2.0 -> 2
        if re.fullmatch(r"\d+\.0", s):
            s = s[:-2]
        return s

    raw_rows: List[Dict[str, str | List[str]]] = []

    for r in range(2, ws.max_row + 1):
        risk = sval(ws.cell(row=r, column=cols["risk"]).value)
        cause = sval(ws.cell(row=r, column=cols["cause"]).value)
        tests_raw = ws.cell(row=r, column=cols["tests"]).value
        tests_list = _split_tests_cell("" if tests_raw is None else str(tests_raw))

        if not (risk or cause or tests_list):
            continue

        # ОСТАВЛЯЕМ ТОЛЬКО выбранные тесты (и в ПОРЯДКЕ выбора)
        matched_tests: List[str] = []
        if sel_names:
            for sname in sel_names:
                for t in tests_list:
                    if _is_match(sname, t):
                        if t not in matched_tests:
                            matched_tests.append(t)
            if not matched_tests:
                continue
        else:
            matched_tests = tests_list

        row = {
            "risk": risk,
            "cause": cause,
            "prob_letter": sval(ws.cell(row=r, column=cols["prob_l"]).value),
            "prob_score": ival(ws.cell(row=r, column=cols["prob_s"]).value),
            "sev_letter": sval(ws.cell(row=r, column=cols["sev_l"]).value),
            "sev_score": ival(ws.cell(row=r, column=cols["sev_s"]).value),
            "det_letter": sval(ws.cell(row=r, column=cols["det_l"]).value),
            "det_score": ival(ws.cell(row=r, column=cols["det_s"]).value),
            "level_letter": sval(ws.cell(row=r, column=cols["level_l"]).value),
            "rpn": ival(ws.cell(row=r, column=cols["rpn"]).value),
            "tests": matched_tests,
        }
        raw_rows.append(row)

    # СХЛОПНУТЬ дубли по всем полям, кроме tests
    merged: List[Dict[str, str | List[str]]] = []
    index: Dict[Tuple, int] = {}

    for rr in raw_rows:
        k = (
            _match_key(rr["risk"]),
            _match_key(rr["cause"]),
            rr["prob_letter"],
            rr["prob_score"],
            rr["sev_letter"],
            rr["sev_score"],
            rr["det_letter"],
            rr["det_score"],
            rr["level_letter"],
            rr["rpn"],
        )
        if k in index:
            ex = merged[index[k]]
            ex_tests = ex["tests"]  # type: ignore[assignment]
            for t in rr["tests"]:   # type: ignore[operator]
                if t not in ex_tests:
                    ex_tests.append(t)
        else:
            index[k] = len(merged)
            merged.append(rr)

    # Привести к финальному виду (tests -> list[str] оставляем, дальше в docx вставке сделаем буллеты)
    return [r for r in merged]  # type: ignore[return-value]


# =============================================================================
# DOCX: вставка Таблицы 5 по плейсхолдерам, НЕ ТРОГАЯ ШАПКУ
# =============================================================================

def _find_table5_and_template_row(doc: DocxDocument) -> Tuple[Table, int]:
    """
    Ищем строку-шаблон по маркеру <<T5_RISK>>.
    """
    for tbl in doc.tables:
        for ri, row in enumerate(tbl.rows):
            if any("<<T5_RISK>>" in c.text for c in row.cells):
                return tbl, ri
    raise ValueError("Не найдена Таблица 5: нет строки с <<T5_RISK>>.")


def _remove_rows_from(table: Table, start_idx: int) -> None:
    """
    Удаляем строки начиная со start_idx и до конца.
    """
    while len(table.rows) > start_idx:
        tr = table.rows[start_idx]._tr
        table._tbl.remove(tr)


def _set_para_text_keep_runs(p, text: str) -> None:
    """
    Сменить текст в первом run и очистить остальные,
    чтобы не ломать стиль абзаца.
    """
    if p.runs:
        p.runs[0].text = text
        for r in p.runs[1:]:
            r.text = ""
    else:
        p.add_run(text)


def _set_cell_lines(cell: _Cell, lines: List[str]) -> None:
    """
    Записать список строк как отдельные абзацы в ячейку.
    """
    if not lines:
        lines = [""]

    while len(cell.paragraphs) < len(lines):
        cell.add_paragraph("")

    for i, txt in enumerate(lines):
        _set_para_text_keep_runs(cell.paragraphs[i], txt)

    # остальные абзацы очистим
    for j in range(len(lines), len(cell.paragraphs)):
        _set_para_text_keep_runs(cell.paragraphs[j], "")


def _set_diag_cell(cell: _Cell, top_left: str, bottom_right: str,
                   bottom_space_before_pt: float = 36.0, after_pt: float = 3.0) -> None:
    """
    Диагональная ячейка: 2 абзаца:
      1) слева (буква)
      2) справа снизу (балл)
    Не трогаем границы/диагональ — они в XML ячейки.
    """
    while len(cell.paragraphs) < 2:
        cell.add_paragraph("")

    p_top = cell.paragraphs[0]
    p_bot = cell.paragraphs[1]

    _set_para_text_keep_runs(p_top, top_left or "")
    p_top.alignment = WD_ALIGN_PARAGRAPH.LEFT
    p_top.paragraph_format.space_before = Pt(0)
    p_top.paragraph_format.space_after = Pt(after_pt)

    _set_para_text_keep_runs(p_bot, bottom_right or "")
    p_bot.alignment = WD_ALIGN_PARAGRAPH.RIGHT
    p_bot.paragraph_format.space_before = Pt(bottom_space_before_pt)
    p_bot.paragraph_format.space_after = Pt(after_pt)

    for p in cell.paragraphs[2:]:
        _set_para_text_keep_runs(p, "")


def insert_table5_into_doc(doc: DocxDocument, risk_rows: List[Dict[str, str]]) -> None:
    """
    Заполняем Таблицу 5 по строкам из get_risk_rows():
    - Шапку не трогаем
    - Строку с плейсхолдерами удаляем
    - Вставляем новые строки, копируя формат строки-шаблона
    - Риск объединяем по вертикали, если одинаковый подряд
    """
    table, tpl_row_idx = _find_table5_and_template_row(doc)

    tpl_tr = deepcopy(table.rows[tpl_row_idx]._tr)

    # удаляем плейсхолдер-строку и всё ниже (чтобы заглушки не оставались)
    _remove_rows_from(table, tpl_row_idx)

    for rr in (risk_rows or []):
        table._tbl.append(deepcopy(tpl_tr))
        new_row = table.rows[-1]
        cells = new_row.cells

        # ВАЖНО: в шаблоне ожидается 7 визуальных колонок:
        # 0 риск | 1 причина | 2 prob | 3 sev | 4 det | 5 level | 6 tests
        _set_cell_lines(cells[0], [str(rr.get("risk", "") or "")])
        _set_cell_lines(cells[1], [str(rr.get("cause", "") or "")])

        _set_diag_cell(cells[2], str(rr.get("prob_letter", "") or ""), str(rr.get("prob_score", "") or ""))
        _set_diag_cell(cells[3], str(rr.get("sev_letter", "") or ""), str(rr.get("sev_score", "") or ""))
        _set_diag_cell(cells[4], str(rr.get("det_letter", "") or ""), str(rr.get("det_score", "") or ""))
        _set_diag_cell(cells[5], str(rr.get("level_letter", "") or ""), str(rr.get("rpn", "") or ""))

        tests_list = rr.get("tests")  # может быть list[str]
        if isinstance(tests_list, list):
            lines = [f"•→{t}" for t in tests_list if str(t).strip()]
        else:
            # если вдруг пришло строкой
            raw = str(tests_list or "").strip()
            lines = [f"•→{x.strip()}" for x in raw.splitlines() if x.strip()] if raw else []

        _set_cell_lines(cells[6], lines if lines else [""])

    # Объединяем одинаковые риски подряд (как в образце)
    if not risk_rows:
        return

    risk_keys = [_match_key(str(r.get("risk", ""))) for r in risk_rows]

    i = 0
    while i < len(risk_rows):
        j = i + 1
        while j < len(risk_rows) and risk_keys[j] == risk_keys[i]:
            j += 1

        if j - i > 1:
            top_cell = table.rows[tpl_row_idx + i].cells[0]
            bottom_cell = table.rows[tpl_row_idx + (j - 1)].cells[0]
            top_cell.merge(bottom_cell)
            _set_cell_lines(top_cell, [str(risk_rows[i].get("risk", "") or "")])

        i = j






def _p_text(p_elm) -> str:
    """Текст абзаца из XML (w:t)."""
    out = []
    for t in p_elm.iter():
        if t.tag == qn("w:t") and t.text:
            out.append(t.text)
    return "".join(out)


def _norm_ws(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip()


def _create_page_break_p() -> OxmlElement:
    """Абзац с разрывом страницы."""
    p = OxmlElement("w:p")
    r = OxmlElement("w:r")
    br = OxmlElement("w:br")
    br.set(qn("w:type"), "page")
    r.append(br)
    p.append(r)
    return p


def _find_caption_and_first_table5(doc: DocxDocument) -> Tuple[Optional[int], Optional[int], Optional[OxmlElement]]:
    """
    Ищем в body:
      - абзац 'Таблица 5' (его индекс в body)
      - первую таблицу сразу после него (индекс в body + сам XML tbl)
    """
    body = doc.element.body
    children = list(body)

    cap_body_idx = None
    for i, ch in enumerate(children):
        if ch.tag == qn("w:p"):
            txt = _norm_ws(_p_text(ch))
            if re.match(r"(?i)^таблица\s*5\b", txt):
                cap_body_idx = i
                break

    if cap_body_idx is None:
        return None, None, None

    tbl_body_idx = None
    tbl_xml = None
    for j in range(cap_body_idx + 1, len(children)):
        ch = children[j]
        if ch.tag == qn("w:tbl"):
            tbl_body_idx = j
            tbl_xml = ch
            break

    return cap_body_idx, tbl_body_idx, tbl_xml


def split_table5_like_example(
    doc: DocxDocument,
    *,
    header_rows: int = 2,
    first_page_data_rows: int = 4,
    next_page_data_rows: int = 6,
) -> None:
    """
    Делит Таблицу 5 "как в 6_OQ — копия":
      - В первой части оставляем шапку (2 строки) + N строк данных
      - Затем: разрыв страницы + 'Продолжение таблицы 5' + таблица ТОЛЬКО со строками данных (без шапки)
      - Если данных много — повторяем блоки (каждый блок по next_page_data_rows)

    Важно: python-docx не умеет реально мерить «влезло/не влезло в страницу»,
    поэтому режем детерминированно по числу строк (как в примере).
    """

    body = doc.element.body
    children = list(body)

    cap_body_idx, tbl_body_idx, tbl_xml = _find_caption_and_first_table5(doc)
    if tbl_body_idx is None or tbl_xml is None:
        return

    # стиль подписи "Таблица 5" (чтобы "Продолжение..." было таким же)
    cap_style = None
    try:
        # сопоставим body абзац с doc.paragraphs (по _p)
        p_map = {p._p: p for p in doc.paragraphs}
        cap_p = p_map.get(children[cap_body_idx], None) if cap_body_idx is not None else None
        cap_style = cap_p.style if cap_p is not None else None
    except Exception:
        cap_style = None

    # защита от повторного запуска: если уже есть "Продолжение таблицы 5" после таблицы — выходим
    for k in range(tbl_body_idx + 1, min(tbl_body_idx + 8, len(children))):
        if children[k].tag == qn("w:p") and re.match(r"(?i)^продолжение\s+таблицы\s*5\b", _norm_ws(_p_text(children[k]))):
            return

    # Сохраним "базовую" таблицу (с tblPr/tblGrid и т.п.)
    base_tbl_xml = deepcopy(tbl_xml)

    # tr_list текущей таблицы
    tr_list: List[OxmlElement] = list(tbl_xml.iterchildren(qn("w:tr")))
    if len(tr_list) <= header_rows:
        return

    header_trs = tr_list[:header_rows]
    data_trs = tr_list[header_rows:]

    if len(data_trs) <= first_page_data_rows:
        return  # всё влезло в первую часть

    # чанки данных
    chunks: List[List[OxmlElement]] = []
    chunks.append(data_trs[:first_page_data_rows])

    rest = data_trs[first_page_data_rows:]
    while rest:
        chunks.append(rest[:next_page_data_rows])
        rest = rest[next_page_data_rows:]

    # 1) Обрезаем первую таблицу: header + первый chunk
    keep_first = set(header_trs + chunks[0])
    for tr in tr_list[::-1]:
        if tr not in keep_first:
            tbl_xml.remove(tr)

    # 2) Вставляем продолжения после первой таблицы
    insert_after_idx = tbl_body_idx

    for part in chunks[1:]:
        # (a) разрыв страницы
        insert_after_idx += 1
        body.insert(insert_after_idx, _create_page_break_p())

        # (b) абзац "Продолжение таблицы 5" (вставляем через add_paragraph и переносим XML)
        p = doc.add_paragraph("Продолжение таблицы 5")
        if cap_style is not None:
            try:
                p.style = cap_style
            except Exception:
                pass
        try:
            p.paragraph_format.keep_with_next = True
        except Exception:
            pass

        p_elm = p._p
        body.remove(p_elm)
        insert_after_idx += 1
        body.insert(insert_after_idx, p_elm)

        # (c) новая таблица: КАК В ПРИМЕРЕ — БЕЗ ШАПКИ, только data rows
        new_tbl = deepcopy(base_tbl_xml)

        # удалить все строки из клона
        for tr in list(new_tbl.iterchildren(qn("w:tr"))):
            new_tbl.remove(tr)

        # добавить строки данных
        for tr in part:
            new_tbl.append(deepcopy(tr))

        insert_after_idx += 1
        body.insert(insert_after_idx, new_tbl)


import re
from copy import deepcopy
from typing import List, Dict
from docx.text.paragraph import Paragraph
from decimal import Decimal

def clear_paragraph(paragraph: Paragraph):
    for run in paragraph.runs:
        paragraph._p.remove(run._r)

Paragraph.clear = clear_paragraph
from docx import Document
from docx.table import Table
from docx.oxml import OxmlElement, CT_P, CT_Tbl
from docx.oxml.ns import qn
from docx.shared import Cm, Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH, WD_LINE_SPACING
from docx.enum.table import WD_ROW_HEIGHT_RULE, WD_ALIGN_VERTICAL
from logger import logger


# -----------------------------------------------------------------------------
# 1) ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ ТЕСТОВЫХ ТАБЛИЦ
# -----------------------------------------------------------------------------
TEST_TITLE_RE = re.compile(r"^\s*Тест\s*11[\.\s]", re.IGNORECASE)

def make_test_titles_bold(doc: Document) -> None:
    """Делает жирным именно фразы вида 'Тест 11.x ...' в первой строке таблиц тестов."""
    for tbl in doc.tables:
        if not tbl.rows:
            continue
        # работаем только с таблицами, у которых в первой строке есть 'Тест 11'
        if not _is_test11_table(tbl):
            # но всё равно проверим параграфы первой строки на всякий случай
            pass
        for cell in tbl.rows[0].cells:
            for p in cell.paragraphs:
                # ищем сам заголовок 'Тест 11.x ...' (а не служебные подписи типа 'Дата проведения')
                if TEST_TITLE_RE.search(p.text or ""):
                    if not p.runs:
                        p.add_run("")
                    for r in p.runs:
                        _force_face_only_tnr(r)   # гарнитура = TNR
                        r.font.bold = True        # только жирность
def find_table_obj_by_title(src_doc: Document, title: str) -> Table:
    sub = title.split('.', 1)[1] if '.' in title else title
    target = re.sub(r'[^\w\s]', '', sub.lower()).strip()
    for tbl in src_doc.tables:
        all_text = " ".join(cell.text for row in tbl.rows for cell in row.cells).lower()
        if target in re.sub(r'[^\w\s]', '', all_text).strip():
            return tbl
    body = src_doc.element.body
    for idx, child in enumerate(body):
        if isinstance(child, CT_P):
            txt = "".join(n.text for n in child.iter() if n.text).lower()
            norm = re.sub(r'[^\w\s]', '', txt).strip()
            if target in norm:
                for nxt in body[idx+1:]:
                    if isinstance(nxt, CT_Tbl):
                        for t in src_doc.tables:
                            if t._tbl is nxt:
                                return t
    raise ValueError(f"Test-table «{title}» not found.")


def create_page_break() -> OxmlElement:
    p = OxmlElement('w:p')
    r = OxmlElement('w:r')
    br = OxmlElement('w:br')
    br.set(qn('w:type'), 'page')
    r.append(br)
    p.append(r)
    return p


def fix_table_xml(tbl_xml: OxmlElement) -> OxmlElement:
    tblPr = tbl_xml.tblPr
    if tblPr is None:
        tblPr = OxmlElement('w:tblPr')
        tbl_xml.insert(0, tblPr)
    layout = OxmlElement('w:tblLayout')
    layout.set(qn('w:type'), 'fixed')
    tblPr.append(layout)
    return tbl_xml


# ---------------------------------------------------------------------------
# ХЕЛПЕРЫ: шрифт Times New Roman и распознавание тест-таблиц
# ---------------------------------------------------------------------------


def _force_face_only_tnr(run) -> None:
    """Ставит TNR для всех семейств (ascii/hAnsi/cs/eastAsia), НЕ меняя размер и жирность."""
    run.font.name = "Times New Roman"
    r = run._element
    rPr = r.get_or_add_rPr()
    rFonts = rPr.rFonts
    if rFonts is None:
        rFonts = OxmlElement('w:rFonts')
        rPr.append(rFonts)
    for attr in ("ascii", "hAnsi", "cs", "eastAsia"):
        rFonts.set(qn(f"w:{attr}"), "Times New Roman")


def _apply_face_only_to_paragraphs(paragraphs) -> None:
    for p in paragraphs:
        if not p.runs:
            p.add_run("")
        for r in p.runs:
            _force_face_only_tnr(r)

def enforce_tnr_face_only_everywhere(doc: Document) -> None:
    """Ставит TNR для всего документа, не меняя размер/жирность/курсив и т.п."""
    # Тело документа: абзацы вне таблиц
    _apply_face_only_to_paragraphs(doc.paragraphs)

    # Таблицы в теле документа
    for t in doc.tables:
        for row in t.rows:
            for cell in row.cells:
                _apply_face_only_to_paragraphs(cell.paragraphs)

    # Колонтитулы всех секций
    for sec in doc.sections:
        _apply_face_only_to_paragraphs(sec.header.paragraphs)
        for t in sec.header.tables:
            for row in t.rows:
                for cell in row.cells:
                    _apply_face_only_to_paragraphs(cell.paragraphs)

        _apply_face_only_to_paragraphs(sec.footer.paragraphs)
        for t in sec.footer.tables:
            for row in t.rows:
                for cell in row.cells:
                    _apply_face_only_to_paragraphs(cell.paragraphs)



def _is_test11_table(tbl) -> bool:
    if not tbl.rows or not tbl.rows[0].cells:
        return False
    head = " ".join(c.text for c in tbl.rows[0].cells)
    return re.search(r"^\s*Тест\s*11[\.\s]", head, flags=re.IGNORECASE) is not None

def _force_run_font_tnr(run, size_pt: int, bold: bool | None = None):
    """
    Жёстко ставим Times New Roman указанного размера для всех семейств (ascii, hAnsi, cs, eastAsia),
    чтобы кириллица не «прыгала» в Calibri и т.п.
    """
    run.font.name = "Times New Roman"
    run.font.size = Pt(size_pt)
    if bold is not None:
        run.font.bold = bold

    r = run._element
    rPr = r.get_or_add_rPr()
    rFonts = rPr.rFonts
    if rFonts is None:
        rFonts = OxmlElement('w:rFonts')
        rPr.append(rFonts)
    for attr in ("ascii", "hAnsi", "cs", "eastAsia"):
        rFonts.set(qn(f"w:{attr}"), "Times New Roman")


def _looks_like_test_table(tbl) -> bool:
    """
    Распознаём ВСЕ тестовые таблицы:
      • «результатные»: содержит «номер помещения» и «площад» и («точк» или «№»),
        ИЛИ содержит «результат» и «испытан»;
      • «описательные»: содержит хотя бы одно из: «дата проведения»,
        «контролируемый параметр», «критерий приемлемости», «квалификационное испытание».
    """
    if not tbl.rows:
        return False
    hdr = " ".join(c.text for c in tbl.rows[0].cells).lower()

    # результатные варианты
    points_like = ("номер помещения" in hdr and "площад" in hdr and ("точк" in hdr or "№" in hdr))
    results_like = ("результат" in hdr and "испытан" in hdr)

    # описательные варианты
    desc_keys = ("дата провед", "контролируемый параметр", "критерий приемлемости", "квалификационное испытание")
    desc_like = any(k in hdr for k in desc_keys)

    return points_like or results_like or desc_like




# def _apply_tnr_to_test_table(tbl):
#     """Шапка: TNR 11pt жирный, тело: TNR 10pt."""
#     for ri, row in enumerate(tbl.rows):
#         is_header = (ri == 0)
#         for cell in row.cells:
#             for p in cell.paragraphs:
#                 for run in p.runs:
#                     _force_run_font_tnr(run, 11 if is_header else 10, bold=is_header)
#
#     try:
#         for tbl in doc.tables:
#             if _looks_like_test_table(tbl):
#                 _apply_tnr_to_test_table(tbl)
#                 _zero_cell_margins(tbl)
#     except NameError:
#         pass


def _zero_cell_margins(tbl) -> None:
    """
    Обнуляет внутренние поля ячеек таблицы (top/left/bottom/right = 0).
    Делается через поиск узлов w:tblCellMar и w:top/left/bottom/right.
    """
    t = tbl._tbl
    tblPr = t.tblPr
    if tblPr is None:
        tblPr = OxmlElement('w:tblPr')
        t.insert(0, tblPr)

    # w:tblCellMar
    mar = tblPr.find(qn('w:tblCellMar'))
    if mar is None:
        mar = OxmlElement('w:tblCellMar')
        tblPr.append(mar)

    # w:top/left/bottom/right
    for side in ('top', 'left', 'bottom', 'right'):
        el = mar.find(qn(f'w:{side}'))
        if el is None:
            el = OxmlElement(f'w:{side}')
            mar.append(el)
        el.set(qn('w:w'), '0')     # 0 twips
        el.set(qn('w:type'), 'dxa')


def _format_table_tnr_no_margins(tbl) -> None:
    # 0) отключить авто-подгон
    tbl.allow_autofit = False

    # 1) обнулить внутренние поля ячеек (снимает «поля»/паддинги)
    _zero_cell_margins(tbl)

    # 2) абзацные параметры: без отступов/интервалов, межстрочный ~1.1
    for row in tbl.rows:
        for cell in row.cells:
            for p in cell.paragraphs:
                pf = p.paragraph_format
                pf.first_line_indent = Cm(0)
                pf.left_indent = Cm(0)
                pf.right_indent = Cm(0)
                pf.space_before = Pt(0)
                pf.space_after = Pt(0)
                pf.line_spacing_rule = WD_LINE_SPACING.MULTIPLE
                pf.line_spacing = 1.1
                # на всякий случай выравнивание влево, чтобы не выглядело как «отступ»
                p.alignment = WD_ALIGN_PARAGRAPH.LEFT

    # 3) только гарнитура TNR (без изменения размера/жирности)
    for row in tbl.rows:
        for cell in row.cells:
            for p in cell.paragraphs:
                if not p.runs:
                    p.add_run("")
                for r in p.runs:
                    _force_face_only_tnr(r)


# -----------------------------------------------------------------------------
# 2) ОБРАБОТКА ТАБЛИЦ ПОМЕЩЕНИЙ
# -----------------------------------------------------------------------------

def process_rooms_table(doc: Document, rooms: List[Dict[str, str]]) -> None:
    logger.debug("Начинаем process_rooms_table")
    tbl = next(
        (t for t in doc.tables
         if t.rows and "Номер помещения" in t.rows[0].cells[0].text),
        None
    )
    if not tbl:
        raise ValueError("Таблица помещений не найдена (header 'Номер помещения').")

    header_map = {
        "#": "Номер помещения", "##": "Наименование помещений",
        "###": "Класс чистоты", "####": "Площадь, м²",
        "#$": "Объём, м³", "#$$": "Перепад давления, Па (±5 Па)",
        "#$$$": "Расход приточного воздуха, м³/ч", "#%": "Кратность воздухообмена, ч⁻¹, не менее",
        "#%%": "Температура, °C", "#%%%": "Относительная влажность, %"
    }
    hdr = tbl.rows[0]
    hdr.height = Cm(3.4)
    hdr.height_rule = WD_ROW_HEIGHT_RULE.EXACTLY
    for cell in hdr.cells:
        for para in cell.paragraphs:
            para.alignment = WD_ALIGN_PARAGRAPH.CENTER  # Центрирование
            pf = para.paragraph_format
            pf.left_indent = Cm(0)
            pf.right_indent = Cm(0)
            pf.first_line_indent = Cm(0)
            pf.space_before = Pt(0)
            pf.space_after = Pt(0)
            pf.line_spacing_rule = WD_LINE_SPACING.MULTIPLE
            pf.line_spacing = 1.1
            for run in para.runs:
                key = run.text.strip()
                if key in header_map:
                    run.text = header_map[key]
                    run.font.name = "Times New Roman"
                    _force_face_only_tnr(run)

    ph2key = {
        "#": "num", "##": "name", "###": "klass", "####": "area",
        "#$": "volume", "#$$": "dp", "#$$$": "airflow", "#%": "exchange",
        "#%%": "temp", "#%%%": "rh"
    }

    # Шаблонная строка
    sample_tr = None
    for row in tbl.rows[1:]:
        if any(cell.text.strip() in ph2key for cell in row.cells):
            sample_tr = deepcopy(row._tr)
            break

    if sample_tr is None:
        raise ValueError("В таблице помещений не найден placeholder row.")

    # Удаляем все строки после заголовка
    while len(tbl.rows) > 1:
        tbl._tbl.remove(tbl.rows[1]._tr)

    for room in rooms:
        tbl._tbl.append(deepcopy(sample_tr))
        new_row = tbl.rows[-1]
        # Устанавливаем высоту строки и вертикальное выравнивание
        new_row.height = Cm(1.46)
        new_row.height_rule = WD_ROW_HEIGHT_RULE.EXACTLY
        for cell in new_row.cells:
            cell.vertical_alignment = WD_ALIGN_VERTICAL.CENTER

        for idx, cell in enumerate(new_row.cells):
            placeholder = cell.text.strip()
            cell.text = ""
            for para in cell.paragraphs:
                para.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
                pf = para.paragraph_format
                pf.first_line_indent = Cm(0)
                pf.left_indent = Cm(0)
                pf.right_indent = Cm(0)
                pf.space_before = Pt(0)
                pf.space_after = Pt(0)
                pf.line_spacing_rule = WD_LINE_SPACING.MULTIPLE
                pf.line_spacing = 1.1
            if placeholder in ph2key:
                run = cell.paragraphs[0].add_run(room.get(ph2key[placeholder], ""))
                run.font.name = "Times New Roman"
                run.font.size = Pt(10)

    logger.debug("process_rooms_table выполнен")



# -----------------------------------------------------------------------------
# 3) ОБРАБОТКА ТАБЛИЦ ОБОРУДОВАНИЯ
# -----------------------------------------------------------------------------

def process_equipment_table(doc: Document, equipment: List[Dict[str, str]]) -> None:
    """
    Заполняет таблицу средств измерений.
    Ищем таблицу, где в ЛЮБОЙ строке встречаются плейсхолдеры @1..@4.
    Строка, содержащая любой из @1..@4, используется как шаблон.
    Все строки после неё удаляются и заменяются клонами с данными из `equipment`.
    """
    logger.debug("Начинаем process_equipment_table")

    PH = ("@1", "@2", "@3", "@4")

    # 1) Найти таблицу по наличию плейсхолдеров в ЛЮБОЙ строке
    tbl = None
    for t in doc.tables:
        found = False
        for r in t.rows:
            if any(any(ph in c.text for ph in PH) for c in r.cells):
                found = True
                break
        if found:
            tbl = t
            break
    if tbl is None:
        raise ValueError("Таблица оборудования не найдена (в таблице нет @1..@4).")

    # 2) Найти шаблонную строку — ту, где реально лежат @1..@4
    sample_idx = None
    for i, row in enumerate(tbl.rows):
        if any(any(ph in c.text for ph in PH) for c in row.cells):
            sample_idx = i
            break
    if sample_idx is None:
        raise ValueError("Не нашли шаблонную строку в таблице оборудования.")

    # Сохраняем все строки ДО шаблонной (это заголовочный блок)
    header_rows_to_keep = sample_idx
    sample_tr = deepcopy(tbl.rows[sample_idx]._tr)

    # 3) Удалить все строки, начиная с sample_idx
    for i in range(len(tbl.rows) - 1, header_rows_to_keep - 1, -1):
        tbl._tbl.remove(tbl.rows[i]._tr)

    # 4) Заполнять
    for eq in equipment:
        tbl._tbl.append(deepcopy(sample_tr))
        new_row = tbl.rows[-1]

        # Сформировать значения
        date_str = (eq.get("date") or "").strip()
        until_str = (eq.get("until") or "").strip()
        date_full = f"{date_str} / {until_str}".strip(" /")

        values = [
            eq.get("name_sn", "") or "",   # @1
            eq.get("params", "") or "",    # @2
            eq.get("cert", "") or "",      # @3
            date_full,                     # @4
        ]

        # 5) Очистка содержимого ячеек строки-шаблона и запись текста
        for ci, cell in enumerate(new_row.cells):
            # чистим все ранны в абзацах
            for p in cell.paragraphs:
                # формат абзаца
                pf = p.paragraph_format
                pf.first_line_indent = Cm(0)
                pf.left_indent = Cm(0)
                pf.right_indent = Cm(0)
                pf.space_before = Pt(0)
                pf.space_after = Pt(0)
                pf.line_spacing_rule = WD_LINE_SPACING.MULTIPLE
                pf.line_spacing = 1.1
                p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

                for r in list(p.runs):
                    p._p.remove(r._r)

            text = values[ci] if ci < len(values) else ""
            run = cell.paragraphs[0].add_run(text)
            run.font.name = "Times New Roman"
            run.font.size = Pt(10)

    logger.debug("process_equipment_table выполнен")





# -----------------------------------------------------------------------------
# 4) ВСТАВКА ТЕСТОВЫХ ТАБЛИЦ
# -----------------------------------------------------------------------------
def extract_total_flows_from_test11(doc: Document) -> list[Decimal]:
    """
    Возвращает список «фактический суммарный» по помещениям в порядке следования,
    сканируя таблицу «Тест 11. Проверка расхода приточного воздуха».
    Берём столбец с заголовком, содержащим 'фактический суммарный',
    и собираем непустые верхушки vMerge-блоков (по одной на помещение).
    """
    def norm(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip().lower()

    for tbl in doc.tables:
        if not tbl.rows:
            continue
        hdr = " ".join(norm(c.text) for c in tbl.rows[0].cells)
        if "расход приточного воздуха" in hdr and "фактический суммарный" in hdr:
            # найти индекс колонки «фактический суммарный»
            fact_sum_col = None
            for ci, c in enumerate(tbl.rows[0].cells):
                if "фактический суммарный" in norm(c.text):
                    fact_sum_col = ci
                    break
            if fact_sum_col is None:
                continue

            vals: list[Decimal] = []
            last_seen = None
            for r in tbl.rows[1:]:
                if fact_sum_col >= len(r.cells):
                    continue
                t = norm(r.cells[fact_sum_col].text)
                # в vMerge верхняя ячейка содержит число, нижние — пустые
                if t and t != last_seen:
                    # вытащим число (запятая/точка)
                    num = re.sub(r"[^\d,.\-]", "", t).replace(",", ".")
                    try:
                        vals.append(Decimal(num))
                    except Exception:
                        pass
                    last_seen = t
            return vals
    return []



def insert_test_tables(
    doc: Document,
    tests_docx_path: str,
    selected_tests: List[str]
) -> List[str]:
    """
    Вставляет выбранные тест-таблицы из tests_docx_path в место плейсхолдера {{TABLE}}
    (поддерживаются варианты {{ TABLE }}, __TABLE__, ___TABLE_PLACEHOLDER___),
    перенумеровывает заголовки "Тест 11.x …" и приводит таблицы к единому формату:
    Times New Roman (шапка 11pt жирный, тело 10pt), без абзацных отступов и без внутренних полей ячеек.
    """
    src = Document(tests_docx_path)
    elems: List[OxmlElement] = []
    missing: List[str] = []

    # 1) подобрать и подготовить таблицы из источника
    for idx, title in enumerate(selected_tests, start=1):
        try:
            tbl = find_table_obj_by_title(src, title)

            # перенумеровка заголовка "Тест 11.{idx} ..."
            header_cell = tbl.rows[0].cells[0]
            header_text = header_cell.text.strip()
            m = re.match(r'(Тест)\s*\d+(?:\.\d+)?\.?\s*(.+)', header_text)
            if m:
                base, rest = m.groups()
                new_title = f"{base} 11.{idx} {rest}"
                p0 = header_cell.paragraphs[0]
                for run in list(p0.runs):
                    p0._p.remove(run._r)
                r = p0.add_run(new_title)
                _force_face_only_tnr(r)  # только гарнитура
                r.font.bold = True

            elems.append(fix_table_xml(deepcopy(tbl._tbl)))
        except Exception as ex:
            missing.append(f"{title}: {ex}")

    # 2) вставка вместо плейсхолдера
    PLACEHOLDERS = ("{{TABLE}}", "{{ TABLE }}", "__TABLE__", "___TABLE_PLACEHOLDER___")
    anchor_found = False
    for para in doc.paragraphs:
        full = "".join(run.text for run in para.runs) or para.text or ""
        if any(ph in full for ph in PLACEHOLDERS):
            parent = para._p.getparent()
            pos = list(parent).index(para._p)
            parent.remove(para._p)
            for i, xml in enumerate(elems):
                parent.insert(pos, xml); pos += 1
                if i < len(elems) - 1:
                    parent.insert(pos, create_page_break()); pos += 1
            anchor_found = True
            break

    if not anchor_found and elems:
        logger.warning("Плейсхолдер таблиц не найден. Убедитесь, что в шаблоне есть {{ TABLE }} в отдельном абзаце.")

    # 3) единая типографика/шрифт/отступы для ВСТАВЛЕННЫХ тестовых таблиц
    for tbl in doc.tables:
        tbl.allow_autofit = False
        for row in tbl.rows:
            for cell in row.cells:
                for p in cell.paragraphs:
                    pf = p.paragraph_format
                    pf.left_indent = Cm(0)
                    pf.right_indent = Cm(0)
                    pf.first_line_indent = Cm(0)
                    pf.space_before = Pt(0)
                    pf.space_after = Pt(0)
                    pf.line_spacing_rule = WD_LINE_SPACING.MULTIPLE
                    pf.line_spacing = 1.1
                    pf.contextual_spacing = False

        # Шапка: Times New Roman 11, жирный
        hdr = tbl.rows[0]
        for cell in hdr.cells:
            for p in cell.paragraphs:
                for r in p.runs:
                    _force_face_only_tnr(r)

# -----------------------------------------------------------------------------
# 5) ЗАПОЛНЕНИЕ РЕЗУЛЬТАТОВ ТЕСТОВЫХ ТАБЛИЦ ДАННЫМИ ПОМЕЩЕНИЙ
# -----------------------------------------------------------------------------

def process_test_results_tables(doc: Document, rooms: List[Dict[str, str]]) -> None:
    """
    Ищет в результатных тестовых таблицах блоки точек измерений и:
      - объединяет колонки 0 и 1 ТОЛЬКО по строкам с номером точки (цифра в колонке "№ точки"),
      - НЕ включает строку "Среднее" в объединение (это ключ к исправлению),
      - центрирует ячейки блока (кроме первых двух),
      - в конце приводит тест-таблицы к единому формату (если есть _looks_like_test_table/_format_table_tnr_no_margins).
    """
    logger.debug("Начинаем process_test_results_tables")

    def norm(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip()

    def is_results_header(row) -> bool:
        j = " ".join(norm(c.text).lower() for c in row.cells)
        return ("номер" in j and "помещени" in j) and ("площад" in j) and ("точк" in j or "№" in j)

    def is_comments_row(row) -> bool:
        return "КОММЕНТАРИИ" in norm(row.cells[0].text).upper() if row.cells else False

    def find_point_col(header_row) -> int | None:
        for ci, c in enumerate(header_row.cells):
            t = norm(c.text).lower()
            # "№ точки" / "точк" / просто "№"
            if "точк" in t or t == "№" or "№ точки" in t:
                return ci
        return None

    # Достаём номер точки из ячейки. Для "1¤", "1α", "1." и т.п. — берём первую группу цифр.
    def get_point_number(cell_text: str) -> int | None:
        t = norm(cell_text)
        m = re.search(r"\d+", t)
        if not m:
            return None
        try:
            return int(m.group(0))
        except Exception:
            return None

    # Полная перезапись текста ячейки без изменения tcPr (vMerge и т.п. остаётся)
    def rewrite_cell_text_center(cell, text: str, size_pt: int = 10):
        # удалить все параграфы
        for p in list(cell.paragraphs):
            p._element.getparent().remove(p._element)

        p = cell.add_paragraph()
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        pf = p.paragraph_format
        pf.first_line_indent = Cm(0)
        pf.left_indent = Cm(0)
        pf.right_indent = Cm(0)
        pf.space_before = Pt(0)
        pf.space_after = Pt(0)
        pf.line_spacing_rule = WD_LINE_SPACING.MULTIPLE
        pf.line_spacing = 1.1

        r = p.add_run(text or "")
        r.font.name = "Times New Roman"
        r.font.size = Pt(size_pt)

    for tbl in doc.tables:
        if not tbl.rows:
            continue

        # 1) Найти строку шапки результата
        hdr_idx = None
        for i, row in enumerate(tbl.rows):
            if is_results_header(row):
                hdr_idx = i
        if hdr_idx is None:
            continue

        hdr_row = tbl.rows[hdr_idx]

        # 2) Найти колонку "№ точки"
        point_col = find_point_col(hdr_row)
        if point_col is None:
            # запасной вариант (часто это 2)
            point_col = 2
        if point_col < 0:
            continue

        # 3) Диапазон данных: от строки после шапки до "КОММЕНТАРИИ" или конца таблицы
        end_idx = len(tbl.rows)
        for i in range(hdr_idx + 1, len(tbl.rows)):
            if is_comments_row(tbl.rows[i]):
                end_idx = i
                break

        data_start = hdr_idx + 1
        if data_start >= end_idx:
            continue

        # 4) Собрать блоки ТОЛЬКО из непрерывных строк с номером точки
        #    + дополнительно: если встретили "1" и блок уже начат — начинаем новый (новый фильтр)
        blocks: list[list[int]] = []
        cur: list[int] = []

        for ri in range(data_start, end_idx):
            row = tbl.rows[ri]
            if point_col >= len(row.cells):
                # если вдруг “кривой” ряд — закрываем текущий блок
                if cur:
                    blocks.append(cur)
                    cur = []
                continue

            num = get_point_number(row.cells[point_col].text)

            if num is None:
                # это "Среднее" / пусто / текст — закрываем блок
                if cur:
                    blocks.append(cur)
                    cur = []
                continue

            # если новая серия начинается с 1 — закрываем предыдущую серию
            if num == 1 and cur:
                blocks.append(cur)
                cur = []

            cur.append(ri)

        if cur:
            blocks.append(cur)

        # 5) Применить объединения (колонки 0 и 1) только по строкам точек
        for block in blocks:
            if len(block) <= 1:
                continue

            top = block[0]

            # Колонка 0
            try:
                c0 = tbl.rows[top].cells[0]
                v0 = norm(c0.text)
                for ri in block[1:]:
                    c0 = c0.merge(tbl.rows[ri].cells[0])
                rewrite_cell_text_center(c0, v0, size_pt=10)
            except Exception as e:
                logger.warning(f"Не удалось объединить колонку 0 в блоке {block}: {e}")

            # Колонка 1
            try:
                c1 = tbl.rows[top].cells[1]
                v1 = norm(c1.text)
                for ri in block[1:]:
                    c1 = c1.merge(tbl.rows[ri].cells[1])
                rewrite_cell_text_center(c1, v1, size_pt=10)
            except Exception as e:
                logger.warning(f"Не удалось объединить колонку 1 в блоке {block}: {e}")

            # Центрирование остальных колонок внутри блока (только строк точек)
            for ri in block:
                row = tbl.rows[ri]
                for ci, cell in enumerate(row.cells):
                    if ci >= 2 and cell.paragraphs:
                        cell.paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER

    # ФИНАЛ: привести тест-таблицы к общему виду (если ваши хелперы определены)
    try:
        for t in doc.tables:
            if _looks_like_test_table(t):
                _format_table_tnr_no_margins(t)
    except Exception:
        pass

    logger.debug("process_test_results_tables завершён")


# template_renderer.py

from typing import Dict, Any, List, Optional
from docxtpl import DocxTemplate, InlineImage
from docx import Document
from docx.shared import Mm
from logger import logger
from file_utils import temp_docx

AREA_THRESHOLDS = [
    (2,1),(4,2),(6,3),(8,4),(10,5),
    (24,6),(28,7),(32,8),(36,9),(52,10),
    (56,11),(64,12),(68,13),(72,14),(76,15),
    (104,16),(108,17),(116,18),(148,19),(156,20),
    (192,21),(232,22),(276,23),(352,24),(436,25),
    (636,26),(1000,27),
]

def _calc_points(area: float) -> int:
    for thr, n in AREA_THRESHOLDS:
        if area <= thr:
            return n
    return 27
# -------------------------------------------

def build_context(
    ctx_fields: Dict[str, str],
    rooms: List[Dict[str, str]],
    tests_placeholder: str = "{{TABLE}}"
) -> Dict[str, Any]:
    """
    Собирает контекст для рендеринга Jinja-плейсхолдеров: добавляет в rooms поле point.
    """
    rooms_ext: List[Dict[str, Any]] = []
    for r in rooms:
        a = str(r.get("area", "")).replace(",", ".")
        try:
            nl = _calc_points(float(a))
        except ValueError:
            nl = 1  # дефолт, если площадь не парсится
        rooms_ext.append({**r, "point": nl})

    ctx = ctx_fields.copy()
    ctx.update({
        "rooms": rooms_ext,
        "TABLE": tests_placeholder,
        "TABLE5": "{{TABLE5}}",
    })
    logger.debug("Контекст для Jinja собран (rooms с point)")
    return ctx

def render_template(
    tpl_path: str,
    context: Dict[str, Any],
    out_path: Optional[str] = None
) -> Document:
    """
    Рендерит DOCX по шаблону.

    :param tpl_path: путь к исходному .docx-шаблону
    :param context: словарь полей для подстановки, включая 'Scan_paths'
    :param out_path: если указан — сохранить итоговый документ сразу по этому пути
    :return: объект python-docx Document для дальнейшей обработки
    """
    tpl = DocxTemplate(tpl_path)

    # --- 1) Подготовка InlineImage для нескольких сканов ---
    if "Scan_paths" in context:
        paths = context.pop("Scan_paths")
        images: List[InlineImage] = []
        for p in paths:
            try:
                img = InlineImage(tpl, p, width=Mm(150))
                images.append(img)
                logger.debug(f"InlineImage создан для {p}")
            except Exception as ex:
                logger.error(f"Не удалось создать InlineImage для {p}: {ex}")
        # в шаблоне используем {% for img in Scans %}{{ img }}{% endfor %}
        context["Scans"] = images

    # --- 2) (если нужен единичный режим) InlineImage для одного скана ---
    if "Scan_path" in context:
        img_path = context.pop("Scan_path")
        try:
            img = InlineImage(tpl, img_path, width=Mm(100))
            context["Scan"] = img
            logger.debug(f"InlineImage создан для {img_path}")
        except Exception as ex:
            logger.error(f"Не удалось создать InlineImage для {img_path}: {ex}")

    # --- 3) рендер всех плейсхолдеров ---
    tpl.render(context)

    # --- 4) сохранение и возврат Document ---
    if out_path:
        tpl.save(out_path)
        logger.info(f"Шаблон отререндерен и сохранён в {out_path}")
        return Document(out_path)

    with temp_docx() as tmp:
        tpl.save(tmp)
        doc = Document(tmp)
        logger.info("Шаблон отререндерен во временный файл")
        return doc



# word_repeat_headers.py
from __future__ import annotations

import re
from copy import deepcopy
from typing import Optional

from docx.document import Document as DocxDocument
from docx.table import Table
from docx.oxml.ns import qn
from docx.oxml import OxmlElement


def _norm(s: str) -> str:
    s = "" if s is None else str(s)
    s = (
        s.replace("\u00A0", " ")
         .replace("\u202F", " ")
         .replace("\u200B", "")
         .replace("\u00AD", "")
    )
    s = re.sub(r"\s+", " ", s).strip().lower()
    return s.replace("ё", "е")


def _row_text(row) -> str:
    return _norm(" ".join(c.text for c in row.cells))


def _mark_tr_as_header(tr_el) -> None:
    trPr = tr_el.find(qn("w:trPr"))
    if trPr is None:
        trPr = OxmlElement("w:trPr")
        tr_el.insert(0, trPr)

    if trPr.find(qn("w:tblHeader")) is None:
        trPr.append(OxmlElement("w:tblHeader"))


def split_test_results_table(
    doc: DocxDocument,
    *,
    split_phrase: str = "Результаты испытания",
    header_rows: int = 2,
    table_must_contain: Optional[str] = None,
) -> int:
    """
    Разрезает таблицы так, чтобы строка ПОСЛЕ 'split_phrase' стала первой строкой новой таблицы.
    Затем помечает первые header_rows строк новой таблицы как повторяемый заголовок (tblHeader).

    Возвращает количество разрезанных таблиц.
    """
    split_key = _norm(split_phrase)
    must_key = _norm(table_must_contain) if table_must_contain else None

    changed = 0

    for t in doc.tables:
        if not t.rows:
            continue

        if must_key:
            whole = _norm(" ".join(_row_text(r) for r in t.rows[: min(len(t.rows), 6)]))
            if must_key not in whole:
                continue

        marker_idx = None
        for i, row in enumerate(t.rows):
            if split_key in _row_text(row):
                marker_idx = i
                break

        if marker_idx is None:
            continue

        start_new = marker_idx + 1
        if start_new >= len(t.rows):
            continue  # нечего переносить

        # XML таблицы и строки
        tbl_el = t._tbl
        tr_elems = tbl_el.xpath("./w:tr")
        if len(tr_elems) != len(t.rows):
            continue

        # Копия таблицы -> будущая "новая таблица"
        new_tbl_el = deepcopy(tbl_el)
        new_tr_elems = new_tbl_el.xpath("./w:tr")

        # В НОВОЙ таблице оставляем строки начиная с start_new
        for i in range(len(new_tr_elems) - 1, -1, -1):
            if i < start_new:
                new_tbl_el.remove(new_tr_elems[i])

        # В СТАРОЙ таблице оставляем строки до start_new-1 (включая 'Результаты испытания')
        for i in range(len(tr_elems) - 1, -1, -1):
            if i >= start_new:
                tbl_el.remove(tr_elems[i])

        # Пометить первые header_rows строк новой таблицы как повторяемый заголовок
        new_tr_elems2 = new_tbl_el.xpath("./w:tr")
        for i in range(min(header_rows, len(new_tr_elems2))):
            _mark_tr_as_header(new_tr_elems2[i])

        # Вставить новую таблицу сразу после старой
        tbl_el.addnext(new_tbl_el)

        changed += 1

    return changed



"""
word_table5_splitter.py

Разделение Таблицы 5 на 2 части + "Продолжение таблицы 5"
СТРОГО по фактическому переносу на новую страницу (по пагинации MS Word).

Гарантии:
- копируем ИМЕННО диапазон шапки (первые header_rows строк) -> НЕТ дублей
- шапка в продолжении ПОЛНАЯ (включая "Аттестационное испытание") за счет добора Range по Find()
- убираем пустой абзац СРАЗУ ПОСЛЕ ШАПКИ (между шапкой и продолжением) корректно
- НЕ даем "таблице-легенде" (Вероятность возникновения/Балл/...) прилипнуть к Таблице 5
- работает при vMerge, где Rows/Cell(row,col) могут ломаться

Требования:
- Windows
- установлен MS Word
- установлен pywin32 (win32com, pythoncom)
"""

from __future__ import annotations

import re
from typing import Optional

from logger import logger


# ------------------------------- helpers -------------------------------

def _norm_basic(s: str) -> str:
    s = "" if s is None else str(s)
    # Word добавляет маркеры конца ячейки/строки: \r и \x07
    s = s.replace("\r", " ").replace("\x07", " ")
    s = (
        s.replace("\u00A0", " ")
         .replace("\u202F", " ")
         .replace("\u200B", "")
         .replace("\u00AD", "")
    )
    s = re.sub(r"\s+", " ", s).strip().lower()
    return s.replace("ё", "е")


def _looks_like_table5_by_placeholder(tbl) -> bool:
    """Самый надежный детектор — по плейсхолдерам."""
    try:
        txt = _norm_basic(tbl.Range.Text)
        return ("<<t5_risk>>" in txt) or ("t5_risk" in txt) or ("t5_" in txt)
    except Exception:
        return False


def _looks_like_table5_word(tbl) -> bool:
    """Fallback детектор по тексту таблицы."""
    try:
        txt = _norm_basic(tbl.Range.Text)
        must = (
            ("риск" in txt) and
            ("возможн" in txt and "причин" in txt) and
            ("аттестацион" in txt and "испыт" in txt)
        )
        placeholders = ("t5_" in txt)
        return must or placeholders
    except Exception:
        return False


def _find_table5_word(word_doc):
    """
    Ищем таблицу 5:
    0) по плейсхолдеру <<T5_RISK>> / T5_
    1) через Word Find по "Таблица 5" (берём таблицу после найденного места)
    2) через Word Find по "FMEA таблица 5"
    3) fallback: скан всех таблиц по тексту
    """
    caption_style = None

    # 0) placeholder scan
    try:
        for t in word_doc.Tables:
            if _looks_like_table5_by_placeholder(t):
                logger.info("Table5 split: нашли таблицу 5 по плейсхолдеру.")
                return t, None
    except Exception:
        pass

    def _try_find_and_take_table(find_text: str):
        nonlocal caption_style
        try:
            rng = word_doc.Content
            f = rng.Find
            f.ClearFormatting()
            ok = f.Execute(
                FindText=find_text,
                MatchCase=False,
                MatchWholeWord=False,
                MatchWildcards=False,
                Forward=True,
                Wrap=1,  # wdFindContinue
            )
            if not ok:
                return None

            try:
                caption_style = rng.Paragraphs(1).Range.Style
            except Exception:
                caption_style = None

            rng_after = word_doc.Range(rng.End, word_doc.Content.End)
            if int(rng_after.Tables.Count) > 0:
                t = rng_after.Tables(1)
                if _looks_like_table5_word(t):
                    return t
            return None
        except Exception:
            return None

    t = _try_find_and_take_table("Таблица 5")
    if t is not None:
        logger.info("Table5 split: нашли таблицу 5 через Find('Таблица 5').")
        return t, caption_style

    t = _try_find_and_take_table("FMEA таблица 5")
    if t is not None:
        logger.info("Table5 split: нашли таблицу 5 через Find('FMEA таблица 5').")
        return t, caption_style

    # fallback scan
    try:
        for tt in word_doc.Tables:
            if _looks_like_table5_word(tt):
                logger.info("Table5 split: нашли таблицу 5 сканированием всех таблиц.")
                return tt, caption_style
    except Exception:
        pass

    return None, caption_style


def _row_anchor_cell(t, row_idx: int):
    """
    Возвращает "якорную" ячейку строки, двигаясь справа налево.
    Нужна для случаев с вертикальными merge, когда некоторые Cell(row,col) недоступны.
    """
    try:
        cols = int(t.Columns.Count)
    except Exception:
        cols = 1

    for col in range(cols, 0, -1):
        try:
            return t.Cell(row_idx, col)
        except Exception:
            continue
    return None


def _get_first_table_after_pos(word_doc, pos: int):
    try:
        rng = word_doc.Range(pos, word_doc.Content.End)
        if int(rng.Tables.Count) > 0:
            return rng.Tables(1)
    except Exception:
        pass
    return None


def _copy_header_range_merge_safe(tbl, header_rows: int, c):
    """
    Делает Range, который покрывает первые header_rows строк таблицы.
    При vMerge MoveEnd(wdRow) может не включить вертикально-объединенную ячейку
    (например "Аттестационное испытание"), поэтому мы ДОБИРАЕМ конец range через Find().
    Возвращает Range (Duplicate) готовый к Copy().
    """
    hdr = tbl.Range.Duplicate
    hdr.Collapse(c.wdCollapseStart)

    moved = hdr.MoveEnd(Unit=c.wdRow, Count=int(header_rows))
    if int(moved) <= 0:
        raise RuntimeError("MoveEnd(wdRow) не смог сдвинуть конец диапазона шапки.")

    # добор по ключевым словам последней большой колонки шапки
    needles = ("Аттестацион", "испыт", "ПЧР")
    for needle in needles:
        try:
            fr = tbl.Range.Duplicate
            f = fr.Find
            f.ClearFormatting()
            ok = f.Execute(
                FindText=needle,
                MatchCase=False,
                MatchWholeWord=False,
                MatchWildcards=False,
                Forward=True,
                Wrap=0,  # wdFindStop
            )
            if not ok:
                continue

            cell = fr.Cells(1)

            # текст должен быть именно в шапке
            try:
                if int(cell.RowIndex) > int(header_rows):
                    continue
            except Exception:
                pass

            end_pos = int(cell.Range.End)
            if end_pos > int(hdr.End):
                hdr.End = end_pos
        except Exception:
            continue

    return hdr


def _looks_like_legend_table(tbl) -> bool:
    """
    Таблица-легенда после анализа рисков обычно содержит "Вероятность возникновения" и "Балл".
    Нужна, чтобы НЕ дать ей прилипнуть к таблице 5.
    """
    try:
        txt = _norm_basic(tbl.Range.Text)
        return ("вероятност" in txt) and ("балл" in txt) and ("уровен" in txt or "риска" in txt)
    except Exception:
        return False


def _ensure_paragraph_between_tables(word_doc, table_a, table_b, c) -> None:
    """
    Если две таблицы идут вплотную (Word может их склеить/перекинуть),
    гарантируем, что между ними есть хотя бы один абзац.
    """
    try:
        a_end = int(table_a.Range.End)
        b_start = int(table_b.Range.Start)
        if b_start <= a_end:
            return

        gap = word_doc.Range(a_end, b_start)
        t = gap.Text or ""

        # если между ними нет абзаца — вставим
        if "\r" not in t:
            r = word_doc.Range(a_end, a_end)
            r.InsertAfter("\r")
    except Exception:
        pass


# ------------------------------- main -------------------------------

def split_table5_with_continuation_open_doc(word_doc, *, header_rows: int = 2) -> bool:
    """
    Делит Таблицу 5 в ОТКРЫТОМ Word-документе (win32com), если она занимает > 1 страницы.
    Возвращает True, если было выполнено разделение, иначе False.
    """
    try:
        import win32com.client as win32
        c = win32.constants
    except Exception as e:
        logger.warning(f"Table5 split: pywin32 не доступен: {e}")
        return False

    logger.info(f"Table5 split: всего таблиц в документе: {int(word_doc.Tables.Count)}")

    tbl, caption_style = _find_table5_word(word_doc)
    if tbl is None:
        logger.warning("Table5 split: Таблица 5 не найдена — пропускаем.")
        return False

    # защита от повторного запуска
    try:
        after_text = word_doc.Range(tbl.Range.End, min(tbl.Range.End + 8000, word_doc.Content.End)).Text
        if re.search(r"продолжение\s+таблицы\s*5", after_text, flags=re.IGNORECASE):
            logger.info("Table5 split: продолжение уже есть — пропускаем.")
            return False
    except Exception:
        pass

    # Запретить Word разрезать одну строку пополам (если получится)
    try:
        tbl.Rows.AllowBreakAcrossPages = False
    except Exception:
        pass

    word_doc.Repaginate()

    def _page_at(pos: int) -> Optional[int]:
        try:
            r = word_doc.Range(pos, pos)
            return int(r.Information(c.wdActiveEndAdjustedPageNumber))
        except Exception:
            try:
                r = word_doc.Range(pos, pos)
                return int(r.Information(c.wdActiveEndPageNumber))
            except Exception:
                return None

    def _range_start_page(rng) -> Optional[int]:
        try:
            return _page_at(int(rng.Start))
        except Exception:
            return None

    def _range_end_page(rng) -> Optional[int]:
        try:
            end_pos = int(rng.End) - 1
            if end_pos < int(rng.Start):
                end_pos = int(rng.Start)
            return _page_at(end_pos)
        except Exception:
            return None

    start_page = _range_start_page(tbl.Range)
    end_page = _range_end_page(tbl.Range)

    if start_page is None or end_page is None:
        logger.warning("Table5 split: не удалось определить страницы таблицы.")
        return False

    if start_page == end_page:
        logger.info("Table5 split: таблица на одной странице — делить не нужно.")
        return False

    rows_count = int(tbl.Rows.Count)
    if rows_count <= header_rows + 1:
        logger.info("Table5 split: слишком мало строк — делить не нужно.")
        return False

    def _row_start_page(t, row_idx: int) -> Optional[int]:
        cell = _row_anchor_cell(t, row_idx)
        if not cell:
            return None
        return _page_at(int(cell.Range.Start))

    def _row_end_page(t, row_idx: int) -> Optional[int]:
        cell = _row_anchor_cell(t, row_idx)
        if not cell:
            return None
        end_pos = int(cell.Range.End) - 1
        if end_pos < int(cell.Range.Start):
            end_pos = int(cell.Range.Start)
        return _page_at(end_pos)

    # --- найти строку, которая уехала на следующую страницу (или ломается) ---
    split_row_idx: Optional[int] = None
    for r in range(header_rows + 1, rows_count + 1):
        rp_start = _row_start_page(tbl, r)
        if rp_start is None:
            continue
        if rp_start > start_page:
            split_row_idx = r
            break
        rp_end = _row_end_page(tbl, r)
        if rp_end is not None and rp_end > rp_start:
            split_row_idx = r
            break

    if split_row_idx is None:
        logger.warning("Table5 split: не нашли строку для переноса/разрыва — пропускаем.")
        return False

    logger.info(f"Table5 split: режем перед строкой {split_row_idx} (страницы {start_page} -> {end_page}).")

    sel = word_doc.Application.Selection

    # =====================================================================
    # 1) КОПИРУЕМ ТОЛЬКО ШАПКУ (Range первых header_rows строк) — без дублей
    # =====================================================================
    try:
        hdr_rng = _copy_header_range_merge_safe(tbl, header_rows, c)
        hdr_rng.Copy()
    except Exception as e:
        logger.warning(f"Table5 split: не удалось скопировать шапку диапазоном: {e}")
        return False

    # =====================================================================
    # 2) SplitTable основной таблицы (tbl) на две части
    # =====================================================================
    try:
        row_anchor = _row_anchor_cell(tbl, split_row_idx)
        if not row_anchor:
            logger.warning("Table5 split: не нашли якорную ячейку строки разреза.")
            return False

        sel.SetRange(int(row_anchor.Range.Start), int(row_anchor.Range.Start))
        sel.SplitTable()
    except Exception as e:
        logger.warning(f"Table5 split: SplitTable не сработал: {e}")
        return False

    # выйти из таблицы к разделяющему абзацу
    for _ in range(2000):
        try:
            if not sel.Information(c.wdWithInTable):
                break
            sel.MoveRight(Unit=c.wdCharacter, Count=1)
        except Exception:
            break

    # разрыв страницы
    try:
        sel.InsertBreak(Type=c.wdPageBreak)
    except Exception as e:
        logger.warning(f"Table5 split: не удалось вставить разрыв страницы: {e}")
        return False

    # "Продолжение таблицы 5"
    try:
        if caption_style is not None:
            try:
                sel.Style = caption_style
            except Exception:
                pass

        sel.ParagraphFormat.Alignment = c.wdAlignParagraphRight
        sel.ParagraphFormat.KeepWithNext = True

        sel.Font.Name = "Times New Roman"
        sel.Font.Size = 12
        sel.Font.Bold = True

        sel.TypeText("Продолжение таблицы 5")
        sel.TypeParagraph()
        sel.Font.Bold = False
    except Exception as e:
        logger.warning(f"Table5 split: не удалось вставить/оформить 'Продолжение таблицы 5': {e}")

    # =====================================================================
    # 3) Находим нижнюю таблицу (продолжение) и вставляем перед ней ШАПКУ
    # =====================================================================
    try:
        tbl2 = _get_first_table_after_pos(word_doc, int(sel.Range.End))
        if tbl2 is None:
            logger.warning("Table5 split: после 'Продолжение таблицы 5' не нашли таблицу.")
            return False
    except Exception as e:
        logger.warning(f"Table5 split: не удалось получить продолжение таблицы: {e}")
        return False

    try:
        # курсор на начало tbl2
        insert_pos = int(tbl2.Range.Start)
        sel.SetRange(insert_pos, insert_pos)
        sel.Collapse(c.wdCollapseStart)

        # выйти из tbl2 в абзац ПЕРЕД таблицей
        moved_out = False
        for _ in range(120):
            if not sel.Information(c.wdWithInTable):
                moved_out = True
                break
            sel.MoveLeft(Unit=c.wdCharacter, Count=1)

        if not moved_out:
            # если не смогли выйти — создадим абзац перед таблицей
            r0 = word_doc.Range(insert_pos, insert_pos)
            r0.InsertBefore("\r")
            sel.SetRange(insert_pos - 1, insert_pos - 1)

        # вставляем шапку (как таблицу)
        paste_pos = int(sel.Range.Start)
        sel.Paste()
        word_doc.Repaginate()

        # определяем вставленную таблицу-шапку
        header_tbl = None
        try:
            if sel.Information(c.wdWithInTable) and int(sel.Tables.Count) > 0:
                header_tbl = sel.Tables(1)
        except Exception:
            header_tbl = None

        if header_tbl is None:
            header_tbl = _get_first_table_after_pos(word_doc, paste_pos)

        if header_tbl is None:
            logger.warning("Table5 split: не удалось определить вставленную таблицу шапки.")
            return False

        # -----------------------------------------------------------------
        # КЛЮЧЕВОЕ: удалить пустой абзац СРАЗУ ПОСЛЕ ШАПКИ
        # Делаем это НАДЕЖНО: берем таблицу, которая идет СРАЗУ ПОСЛЕ header_tbl,
        # и удаляем промежуток ТОЛЬКО между ними.
        # -----------------------------------------------------------------
        data_tbl = _get_first_table_after_pos(word_doc, int(header_tbl.Range.End))
        if data_tbl is None:
            logger.warning("Table5 split: не нашли таблицу продолжения после вставленной шапки.")
            return False

        # если вдруг data_tbl == header_tbl (редко, но бывает) — сдвинем позицию на 1 символ
        try:
            if int(data_tbl.Range.Start) == int(header_tbl.Range.Start):
                data_tbl = _get_first_table_after_pos(word_doc, int(header_tbl.Range.End) + 1)
        except Exception:
            pass

        if data_tbl is None:
            logger.warning("Table5 split: не удалось получить таблицу данных для склейки.")
            return False

        # удаляем РОВНО разрыв между header_tbl и data_tbl -> склеиваются
        try:
            join_rng = word_doc.Range(int(header_tbl.Range.End), int(data_tbl.Range.Start))
            if int(join_rng.End) > int(join_rng.Start):
                join_rng.Delete()
        except Exception as e:
            logger.warning(f"Table5 split: не удалось удалить промежуток между шапкой и продолжением: {e}")

        # после склейки "таблица 5 (продолжение)" — это header_tbl (как первая)
        cont_tbl = header_tbl

        # делаем шапку повторяющейся (если получится)
        try:
            for rr in range(1, header_rows + 1):
                try:
                    cont_tbl.Rows(rr).HeadingFormat = True
                except Exception:
                    pass
        except Exception:
            pass

        # -----------------------------------------------------------------
        # ВАЖНО: НЕ ДАЕМ СЛЕДУЮЩЕЙ ТАБЛИЦЕ (легенде) ПРИЛИПНУТЬ К ТАБЛИЦЕ 5
        # Если сразу после cont_tbl идет таблица-легенда, гарантируем абзац между ними.
        # -----------------------------------------------------------------
        try:
            next_tbl = _get_first_table_after_pos(word_doc, int(cont_tbl.Range.End))
            if next_tbl is not None and _looks_like_legend_table(next_tbl):
                _ensure_paragraph_between_tables(word_doc, cont_tbl, next_tbl, c)
        except Exception:
            pass

        try:
            logger.info(
                f"Table5 split: header inserted+merged; header_rows={header_rows}; "
                f"cols={int(cont_tbl.Columns.Count)}"
            )
        except Exception:
            pass

    except Exception as e:
        logger.warning(f"Table5 split: не удалось вставить/склеить шапку во 2-ю часть: {e}")
        return False

    logger.info("Table5 split: выполнено.")
    return True


def update_fields_with_word(docx_path: str) -> None:
    """
    Открывает DOCX в Word, режет Таблицу 5, обновляет поля/колонтитулы, сохраняет.
    ВАЖНО: вызывается из QThread => обязательно CoInitialize/CoUninitialize.
    """
    try:
        import pythoncom
        import win32com.client as win32
    except Exception as e:
        logger.warning(f"Word postprocess пропущен: pywin32 не установлен/недоступен: {e}")
        return

    pythoncom.CoInitialize()
    word = None
    doc = None
    try:
        word = win32.DispatchEx("Word.Application")
        word.Visible = False
        word.DisplayAlerts = 0

        doc = word.Documents.Open(str(docx_path), ReadOnly=False, AddToRecentFiles=False)

        try:
            doc.Repaginate()
            split_table5_with_continuation_open_doc(doc, header_rows=2)
            doc.Repaginate()
        except Exception as e:
            logger.warning(f"Table5 split: ошибка во время разрезания: {e}")

        # обновление полей
        try:
            doc.Fields.Update()
        except Exception:
            pass

        try:
            for sec in doc.Sections:
                sec.Headers(1).Range.Fields.Update()
                sec.Footers(1).Range.Fields.Update()
        except Exception:
            pass

        doc.Save()
        doc.Close(SaveChanges=False)
        doc = None

    finally:
        try:
            if doc is not None:
                doc.Close(SaveChanges=False)
        except Exception:
            pass
        try:
            if word is not None:
                word.Quit()
        except Exception:
            pass
        pythoncom.CoUninitialize()



# word_test11_splitter.py
from __future__ import annotations

import re
from copy import deepcopy
from typing import Optional

from docx.document import Document as DocxDocument
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx.table import Table


def _norm(s: str) -> str:
    s = "" if s is None else str(s)
    s = s.replace("\u00A0", " ").replace("\u202F", " ").replace("ё", "е")
    s = re.sub(r"\s+", " ", s).strip().lower()
    return s


def _tbl_looks_like_test11_results(tbl: Table) -> bool:
    """
    Очень мягкая проверка, чтобы не резать "левые" таблицы:
    ищем в таблице признаки шапки результатов теста 11.
    """
    if not tbl.rows:
        return False
    # проверим первые ~10 строк на ключевые слова
    probe_rows = tbl.rows[: min(10, len(tbl.rows))]
    txt = " ".join(_norm(c.text) for r in probe_rows for c in r.cells)
    return ("результаты испытания" in txt) and ("фильтр" in txt) and ("расход" in txt)


def _set_repeat_header_rows_on_tbl_el(tbl_el, header_rows: int) -> None:
    """
    Ставит флаг "повторять как заголовок" на первые header_rows строк XML-таблицы.
    Работает напрямую с XML, без необходимости получать объект Table.
    """
    trs = tbl_el.xpath("./w:tr")
    for tr in trs[: max(0, header_rows)]:
        trPr = tr.find(qn("w:trPr"))
        if trPr is None:
            trPr = OxmlElement("w:trPr")
            tr.insert(0, trPr)

        if trPr.find(qn("w:tblHeader")) is None:
            trPr.append(OxmlElement("w:tblHeader"))


def split_after_results_and_repeat_header(
    doc: DocxDocument,
    *,
    header_rows: int = 2,
    results_row_text: str = "Результаты испытания",
) -> bool:
    """
    Находит таблицу результатов "Проверка расхода приточного воздуха",
    ищет строку "Результаты испытания" и РЕЖЕТ таблицу так, что
    строка СРАЗУ ПОСЛЕ неё становится ПЕРВОЙ строкой новой таблицы.

    Далее ставит повтор заголовка (tblHeader) на первые header_rows строк новой таблицы.

    Возвращает True если разрезали, иначе False.
    """

    target_tbl: Optional[Table] = None
    results_row_idx: Optional[int] = None

    for t in doc.tables:
        if not _tbl_looks_like_test11_results(t):
            continue

        # ищем строку "Результаты испытания"
        for ri, row in enumerate(t.rows):
            row_text = _norm(" ".join(c.text for c in row.cells))
            if _norm(results_row_text) == row_text or _norm(results_row_text) in row_text:
                target_tbl = t
                results_row_idx = ri
                break

        if target_tbl is not None:
            break

    if target_tbl is None or results_row_idx is None:
        return False

    split_row_idx = results_row_idx + 1  # <-- строка после "Результаты испытания"
    if split_row_idx >= len(target_tbl.rows):
        return False

    tbl_el = target_tbl._tbl
    tr_elems = tbl_el.xpath("./w:tr")
    if len(tr_elems) != len(target_tbl.rows):
        return False

    # создаём новую таблицу как копию
    new_tbl_el = deepcopy(tbl_el)
    new_tr_elems = new_tbl_el.xpath("./w:tr")

    # в новой таблице удаляем всё ДО split_row_idx
    for i in range(split_row_idx - 1, -1, -1):
        new_tbl_el.remove(new_tr_elems[i])

    # в старой таблице удаляем всё Начиная с split_row_idx
    for i in range(len(tr_elems) - 1, split_row_idx - 1, -1):
        tbl_el.remove(tr_elems[i])

    # вставляем новую таблицу сразу после старой
    tbl_el.addnext(new_tbl_el)

    # делаем повтор шапки на новой таблице (теперь шапка = первые строки)
    _set_repeat_header_rows_on_tbl_el(new_tbl_el, header_rows)

    return True



# word_update_all.py
from __future__ import annotations

import re
from typing import Optional

import win32com.client as win32
from win32com.client import constants as c


def _clean_text(s: str) -> str:
    # Word часто возвращает текст с '\r\x07'
    s = s.replace("\r", "").replace("\x07", "")
    s = s.replace("\u00A0", " ")
    s = re.sub(r"\s+", " ", s).strip()
    return s


def _norm(s: str) -> str:
    s = _clean_text(s).lower()
    return s.replace("ё", "е")


def _table_text_first_rows(tbl, rows: int = 3) -> str:
    """Собираем текст первых N строк таблицы одним куском."""
    rows = min(rows, int(tbl.Rows.Count))
    parts = []
    for i in range(1, rows + 1):
        try:
            r = tbl.Rows(i)
            for cell in r.Cells:
                parts.append(_clean_text(cell.Range.Text))
        except Exception:
            continue
    return " ".join(parts)


def _looks_like_test11_3_table(tbl) -> bool:
    """
    Узнаём таблицу "Тест 11.3 Проверка расхода приточного воздуха" по шапке:
    'Фильтр', 'Скорость потока', 'Расход приточного воздуха', 'Соответствует'
    (и обычно встречается 'ДА'/'НЕТ').
    """
    try:
        if int(tbl.Rows.Count) < 2:
            return False
        head = _norm(_table_text_first_rows(tbl, rows=3))
        return (
            ("фильтр" in head)
            and ("скорост" in head)          # скорость/скорости
            and ("расход" in head)
            and ("приточ" in head)           # приточного
            and ("соответ" in head)          # соответствует
        )
    except Exception:
        return False


def _set_repeat_header(tbl, header_rows_count: int) -> None:
    """
    Делает первые header_rows_count строк повторяемыми как шапку на каждой странице.
    """
    header_rows_count = max(1, header_rows_count)
    max_rows = int(tbl.Rows.Count)
    header_rows_count = min(header_rows_count, max_rows)

    # На всякий: чтобы Word не разрывал строки (особенно шапку) пополам
    try:
        tbl.Rows.AllowBreakAcrossPages = True  # данные можно, если нужно
    except Exception:
        pass

    for i in range(1, header_rows_count + 1):
        try:
            tbl.Rows(i).HeadingFormat = True
        except Exception:
            pass
        try:
            tbl.Rows(i).AllowBreakAcrossPages = False
        except Exception:
            pass


def enforce_test11_3_header_each_page(docx_path: str, header_rows_count: int = 2) -> int:
    """
    Находит все таблицы формата Тест 11.3 и включает повтор шапки на каждой странице.
    Возвращает количество найденных/исправленных таблиц.
    """
    word = win32.gencache.EnsureDispatch("Word.Application")
    word.Visible = False

    changed = 0
    try:
        doc = word.Documents.Open(str(docx_path))
        doc.Repaginate()

        for tbl in doc.Tables:
            if _looks_like_test11_3_table(tbl):
                _set_repeat_header(tbl, header_rows_count=header_rows_count)
                changed += 1

        if changed:
            doc.Save()
        doc.Close()
        return changed
    finally:
        word.Quit()


def update_all_fields_toc_headers(docx_path: str) -> None:
    """
    Полное обновление:
    - Repaginate
    - Fields.Update()
    - обновление полей в колонтитулах
    - обновление содержания (TOC), если есть
    """
    word = win32.gencache.EnsureDispatch("Word.Application")
    word.Visible = False
    try:
        doc = word.Documents.Open(str(docx_path))
        doc.Repaginate()

        # 1) Обновить поля в основном тексте
        try:
            doc.Fields.Update()
        except Exception:
            pass

        # 2) Колонтитулы
        for sec in doc.Sections:
            for hf_idx in (1, 2, 3):  # 1=Primary, 2=FirstPage, 3=EvenPages
                try:
                    sec.Headers(hf_idx).Range.Fields.Update()
                except Exception:
                    pass
                try:
                    sec.Footers(hf_idx).Range.Fields.Update()
                except Exception:
                    pass

        # 3) Содержание (TOC)
        try:
            if doc.TablesOfContents.Count >= 1:
                # Если TOC несколько — обновим все
                for i in range(1, doc.TablesOfContents.Count + 1):
                    try:
                        doc.TablesOfContents(i).Update()
                    except Exception:
                        pass
        except Exception:
            pass

        # 4) Ещё разок для пересчёта NUMPAGES после всех вставок/разрывов
        doc.Repaginate()
        try:
            doc.Fields.Update()
        except Exception:
            pass

        doc.Save()
        doc.Close()
    finally:
        word.Quit()


def finalize_docx(docx_path: str, *, test11_3_header_rows: int = 2) -> None:
    """
    Один вызов на финализацию документа:
    - сделать повтор шапки в таблице Тест 11.3 (на каждой странице)
    - обновить TOC/поля/колонтитулы (NUMPAGES/страницы в содержании)
    """
    enforce_test11_3_header_each_page(docx_path, header_rows_count=test11_3_header_rows)
    update_all_fields_toc_headers(docx_path)
























